<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<script src="/iframe/assets/jszip.min.js"></script>
		<script src="/iframe/assets/pdf.min.js"></script>
		<title>å°è£…ç”Ÿæˆå™¨</title>
		<style>
			body {
				font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
				margin: 0;
				padding: 0;
				background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
				height: 100vh;
				overflow: hidden;
				color: #495057;
			}
			.container {
				display: flex;
				height: 100vh;
				background-color: #ffffff;
				box-shadow: 0 0 20px rgba(0,0,0,0.1);
			}
			.header {
				display: none;
				justify-content: space-between;
				align-items: center;
				padding: 12px 20px;
				background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
				border-bottom: 1px solid #e9ecef;
				box-shadow: 0 2px 4px rgba(0,0,0,0.05);
			}
			h1 {
				margin: 0;
				font-size: 20px;
				font-weight: 600;
				color: #343a40;
				letter-spacing: -0.5px;
			}
			.settings-btn {
				background: #e3f2fd;
				color: #1976d2;
				border: 1px solid #bbdefb;
				border-radius: 4px;
				padding: 0 16px;
				cursor: pointer;
				font-size: 14px;
				font-weight: 400;
				transition: background-color 0.2s ease;
				height: 24px;
				line-height: 24px;
				min-width: 24px;
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 6px;
			}
			.settings-btn:hover {
				background: #bbdefb;
			}
			.settings-modal {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0,0,0,0.5);
				z-index: 1000;
				align-items: center;
				justify-content: center;
			}
			.settings-content {
				background: white;
				border-radius: 12px;
				padding: 24px;
				width: 400px;
				max-width: 90vw;
				box-shadow: 0 10px 30px rgba(0,0,0,0.2);
			}
			.settings-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 20px;
			}
			.settings-title {
				font-size: 18px;
				font-weight: 600;
				color: #343a40;
				margin: 0;
			}
			.close-btn {
				background: none;
				border: none;
				font-size: 24px;
				cursor: pointer;
				color: #6c757d;
				padding: 0;
				width: 24px;
				height: 24px;
				line-height: 24px;
				min-width: 24px;
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 6px;
				transition: all 0.2s ease;
			}
			.close-btn:hover {
				background: #f8f9fa;
				color: #495057;
			}
			.left-panel {
				flex: 1;
				border-right: 1px solid #e9ecef;
				display: flex;
				flex-direction: column;
				background: #ffffff;
			}
			.right-panel {
				flex: 1;
				display: flex;
				flex-direction: column;
				background: #ffffff;
			}
			.form-group {
				margin-bottom: 20px;
			}
			label {
				display: block;
				margin-bottom: 8px;
				font-weight: 500;
				color: #495057;
				font-size: 14px;
			}
			input[type='text'],
			select {
				width: 100%;
				padding: 12px 16px;
				border: 2px solid #e9ecef;
				border-radius: 8px;
				font-size: 14px;
				transition: all 0.3s ease;
				background: #ffffff;
				box-sizing: border-box;
			}
			input[type='text']:focus,
			select:focus {
				outline: none;
				border-color: #6c757d;
				box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
			}
			.upload-section {
				display: none;
				padding: 16px;
				border-bottom: 1px solid #e9ecef;
			}
			.upload-area {
				border: 2px dashed #ced4da;
				border-radius: 8px;
				padding: 20px 16px;
				text-align: center;
				margin-bottom: 12px;
				cursor: pointer;
				transition: all 0.3s ease;
				background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
			}
			.upload-area:hover {
				border-color: #6c757d;
				background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
				transform: translateY(-2px);
				box-shadow: 0 4px 12px rgba(0,0,0,0.1);
			}
			.upload-area.highlight {
				border-color: #6c757d;
				background: linear-gradient(135deg, #e9ecef 0%, #f8f9fa 100%);
				box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
			}
			.upload-area p {
				color: #6c757d;
				margin: 0;
				font-size: 14px;
				font-weight: 500;
			}
			.image-display {
				flex: 1;
				position: relative;
				overflow: hidden;
				background: #f9f9f9;
				display: flex;
				align-items: center;
				justify-content: center;
				border: 2px dashed #ced4da;
				cursor: pointer;
				transition: all 0.3s ease;
			}
			.image-display:hover {
				border-color: #6c757d;
				background: #f1f3f4;
			}
			.image-display.highlight {
				border-color: #6c757d;
				background: #e9ecef;
				box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.1);
			}
			.image-container {
				position: relative;
				width: 100%;
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.image-container img {
				max-width: 100%;
				max-height: 100%;
				object-fit: contain;
				display: block;
				user-select: none;
				-webkit-user-drag: none;
				-khtml-user-drag: none;
				-moz-user-drag: none;
				-o-user-drag: none;
				user-drag: none;
				pointer-events: none;
			}
			.selection-box {
				position: absolute;
				border: 2px solid #2f8ae0;
				background: rgba(47, 138, 224, 0.1);
				pointer-events: none;
				display: block;
				z-index: 15;
				box-sizing: border-box;
				min-width: 1px;
				min-height: 1px;
			}
			.controls-section {
				padding: 12px 16px;
				border-bottom: 1px solid #e9ecef;
				background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
				box-shadow: 0 2px 4px rgba(0,0,0,0.05);
			}
			.control-row {
				display: flex;
				gap: 6px;
				margin-bottom: 8px;
				align-items: center;
				flex-wrap: wrap;
			}
			.control-row.single-row {
				flex-wrap: nowrap;
				gap: 4px;
				justify-content: space-between;
			}
			.control-buttons {
				display: flex;
				gap: 4px;
			}
			.coordinate-display {
				font-size: 12px;
				color: #666;
				margin-top: 5px;
			}
			.progress-container {
				display: flex;
				align-items: center;
				gap: 10px;
				margin-top: 5px;
			}
			.progress-bar {
				flex: 1;
				height: 6px;
				background-color: #e9ecef;
				border-radius: 3px;
				overflow: hidden;
				display: none;
			}
			.progress-fill {
				height: 100%;
				background-color: #007bff;
				transition: width 0.3s ease;
				width: 0%;
			}
			.progress-text {
				font-size: 11px;
				color: #666;
				white-space: nowrap;
				display: none;
			}
			.preview-container {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
				gap: 15px;
				margin-bottom: 20px;
			}
			.preview-item {
				border: 1px solid #eee;
				border-radius: 4px;
				padding: 10px;
				position: relative;
			}
			.preview-item img {
				max-width: 100%;
				height: auto;
				border-radius: 4px;
			}
			.preview-item-info {
				margin-top: 8px;
				font-size: 12px;
			}
			.preview-item-name {
				font-weight: bold;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.preview-item-size {
				color: #888;
			}
			.preview-item-remove {
				position: absolute;
				top: 5px;
				right: 5px;
				background: none;
				border: none;
				font-size: 16px;
				cursor: pointer;
				color: #999;
			}
			.controls {
				display: flex;
				justify-content: space-between;
				margin-bottom: 20px;
			}
			.control-group {
				display: flex;
				gap: 10px;
			}
			button {
				padding: 0 8px;
				background: white;
				color: #2196f3;
				border: 1px solid #2196f3;
				border-radius: 3px;
				cursor: pointer;
				font-size: 11px;
				font-weight: 400;
				transition: all 0.2s ease;
				height: 24px;
				line-height: 24px;
				min-width: 24px;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			button:hover {
				background: #2196f3;
				color: white;
			}
			button:active {
				background: #1976d2;
				color: white;
			}
			button:disabled {
				background: #f5f5f5;
				color: #9e9e9e;
				border-color: #e0e0e0;
				cursor: not-allowed;
			}
			.btn-primary {
				background: #2196f3;
				color: white;
				border-color: #2196f3;
			}
			.btn-primary:hover {
				background: #1976d2;
				border-color: #1976d2;
			}
			.btn-success {
				background: white;
				color: #2196f3;
				border-color: #2196f3;
			}
			.btn-success:hover {
				background: #2196f3;
				color: white;
				border-color: #2196f3;
			}
			.btn-secondary {
				background: white;
				color: #6c757d;
				border-color: #6c757d;
			}
			.btn-secondary:hover {
				background: #6c757d;
				color: white;
				border-color: #6c757d;
			}
			.detection-box {
				position: absolute;
				border: 2px solid #e74c3c;
				background: rgba(231, 76, 60, 0.2);
				pointer-events: none;
				box-sizing: border-box;
			}
			.detection-label {
				position: absolute;
				top: -25px;
				left: 0;
				background: #e74c3c;
				color: white;
				padding: 2px 6px;
				font-size: 12px;
				border-radius: 3px;
				white-space: nowrap;
			}
			.image-viewer.selecting {
				cursor: crosshair;
			}
			.image-viewer.selecting .selection-overlay {
				pointer-events: all;
			}
			.selection-overlay {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				pointer-events: none;
				z-index: 10;
			}
			.results-container {
				border-top: 1px solid #eee;
				padding-top: 20px;
			}
			.results-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 15px;
			}
			.results-count {
				font-weight: bold;
			}
			.results-controls {
				display: flex;
				gap: 15px;
			}
			select {
				padding: 5px;
				border-radius: 4px;
				border: 1px solid #ccc;
			}
			.results-list {
				max-height: 600px;
				overflow-y: auto;
			}
			.result-item {
				border-bottom: 1px solid #eee;
				padding: 15px 0;
			}
			.result-item-header {
				display: flex;
				align-items: center;
				margin-bottom: 10px;
			}
			.result-item-header img {
				width: 40px;
				height: 40px;
				object-fit: cover;
				border-radius: 4px;
				margin-right: 10px;
			}
			.result-item-title {
				font-weight: bold;
				flex: 1;
			}
			.result-item-status {
				color: #4885e0;
			}
			.result-item-content {
				white-space: pre-wrap;
				line-height: 1.5;
			}
			.result-item-footer {
				display: flex;
				gap: 10px;
				margin-top: 10px;
			}
			.result-item.error .result-item-status {
				color: #f44336;
			}
			.cost-container {
				margin-top: 20px;
				padding: 10px;
				background-color: #f9f9f9;
				border-radius: 4px;
			}
			.cost-container div {
				margin: 5px 0;
				display: flex;
				justify-content: space-between;
			}
			.scroll-indicator {
				text-align: center;
				padding: 10px;
				background-color: #f0f0f0;
				color: #666;
				display: none;
			}
			.dark-mode {
				background-color: #333;
				color: #fff;
			}
			.dark-mode .container {
				background-color: #222;
				color: #fff;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
			}
			.dark-mode .upload-area {
				border-color: #555;
			}
			.dark-mode .preview-item {
				border-color: #444;
			}
			.dark-mode .results-list {
				border-color: #444;
			}
			.dark-mode .result-item.error .result-item-status {
				color: #ff5555;
			}
			.dark-mode .cost-container {
				background-color: #333;
			}
			.progress-container {
				margin: 20px 0;
				display: none;
			}
			.progress-bar-container {
				height: 20px;
				background-color: #f0f0f0;
				border-radius: 10px;
				overflow: hidden;
			}
			#progress-bar {
				height: 100%;
				background-color: #2f8ae0;
				width: 0%;
			}
			.timer-container {
				text-align: center;
				margin-top: 10px;
				font-weight: bold;
			}
			.result-card {
				border: 1px solid #eee;
				border-radius: 6px;
				padding: 12px;
				margin-bottom: 10px;
				cursor: pointer;
				transition: all 0.3s;
			}
			.result-card:hover {
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			}
			.result-card-header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 8px;
			}
			.result-card-title {
				font-weight: bold;
			}
			.result-card-content {
				display: none;
				white-space: pre-wrap;
				line-height: 1.4;
				font-size: 13px;
				max-height: 200px;
				overflow-y: auto;
			}
			.result-card-footer {
				display: flex;
				justify-content: flex-end;
				margin-top: 8px;
				gap: 6px;
			}
			.result-card-footer button {
				padding: 4px 8px;
				background-color: #f0f0f0;
				color: #333;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				font-size: 12px;
			}
			.top-right-button {
				background-color: #4caf50;
			}
			.top-right-button:hover {
				background-color: #45a049;
			}
			.pin-table-section {
				flex: 1;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}
			.pin-table {
				width: 100%;
				border-collapse: collapse;
				margin-top: 10px;
				font-size: 11px;
				table-layout: fixed;
			}
			.pin-table th,
			.pin-table td {
				border: 1px solid #ddd;
				padding: 4px 6px;
				text-align: left;
			}
			.pin-table th:nth-child(1),
			.pin-table td:nth-child(1) {
				width: 60px;
			}
			.pin-table th:nth-child(4),
			.pin-table td:nth-child(4) {
				width: 60px;
				text-align: center;
			}
			.pin-table button {
				padding: 0 8px;
				font-size: 10px;
				border-radius: 3px;
				background: #f1848e;
				color: white;
				border: none;
				cursor: pointer;
				height: 24px;
				line-height: 24px;
				min-width: 24px;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.pin-table button:hover {
				background: #c82333;
			}
			.pin-table th {
				background-color: #f5f5f5;
				font-weight: bold;
				font-size: 10px;
			}
			.pin-table tr:nth-child(even) {
				background-color: #f9f9f9;
			}
			.pin-table tr:hover {
				background-color: #e3f2fd;
			}
			.pin-table input {
				width: 100%;
				border: none;
				padding: 4px;
				background: transparent;
			}
			.pin-table input:focus {
				outline: 1px solid #2f8ae0;
				background: white;
			}
			.table-controls {
				display: flex;
				gap: 6px;
				margin-bottom: 8px;
				padding: 12px 16px;
				border-bottom: 1px solid #e9ecef;
				background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
				box-shadow: 0 2px 4px rgba(0,0,0,0.05);
			}
			.table-controls button {
				padding: 0 6px;
				font-size: 10px;
				height: 24px;
				line-height: 24px;
				min-width: 24px;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.pin-table-content {
				flex: 1;
				padding: 16px;
				overflow: auto;
			}
			.empty-state {
				text-align: center;
				color: #999;
				padding: 40px;
				font-style: italic;
			}
			.image-navigation {
				padding: 12px 20px;
				border-top: 1px solid #e9ecef;
				background: #f8f9fa;
			}
			.nav-controls {
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 8px;
				margin-bottom: 8px;
			}
			.nav-btn {
				padding: 0 8px;
				font-size: 12px;
				height: 24px;
				line-height: 24px;
				min-width: 24px;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.nav-btn:disabled {
				opacity: 0.5;
				cursor: not-allowed;
			}
			.image-counter {
				font-weight: 500;
				color: #495057;
				font-size: 12px;
				min-width: 50px;
				text-align: center;
				cursor: pointer;
				padding: 4px 8px;
				border-radius: 4px;
				transition: background-color 0.2s ease;
				position: relative;
			}
			.image-counter:hover {
				background-color: #f8f9fa;
			}
			.image-counter::before {
				content: 'ğŸ“„';
				position: absolute;
				left: -18px;
				top: 50%;
				transform: translateY(-50%);
				font-size: 10px;
				opacity: 0.7;
			}
			#page-input {
				width: 30px;
				border: none;
				background: transparent;
				text-align: center;
				font-size: 12px;
				font-weight: 500;
				color: #495057;
				outline: none;
			}
			#page-input:focus {
				background-color: #fff;
				border: 1px solid #007bff;
				border-radius: 2px;
			}

			.image-info {
				text-align: center;
				font-size: 12px;
				color: #6c757d;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.timing-display {
				font-size: 11px;
				color: #6c757d;
				padding: 4px 8px;
				border: 1px solid #e9ecef;
				border-radius: 3px;
				background: #f8f9fa;
				white-space: nowrap;
				min-width: 80px;
				text-align: center;
				flex-shrink: 0;
				margin-left: auto;
		}
		/* æ›¿æ¢PDFæŒ‰é’®æ ·å¼ */
		.replace-pdf-overlay {
			position: absolute;
			top: 10px;
			left: 10px;
			z-index: 15;
			display: none;
		}

		.replace-pdf-overlay button {
			background: rgba(0, 0, 0, 0.7);
			color: white;
			border: none;
			padding: 0 12px;
			border-radius: 4px;
			font-size: 12px;
			cursor: pointer;
			transition: background-color 0.2s;
			height: 24px;
			line-height: 24px;
			min-width: 24px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.replace-pdf-overlay button:hover {
			background: rgba(0, 0, 0, 0.9);
		}
		
		/* å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡†æ ·å¼ */
		.image-preview-modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.9);
			z-index: 2000;
			align-items: center;
			justify-content: center;
			cursor: pointer;
		}
		
		.image-preview-content {
			position: relative;
			max-width: 90vw;
			max-height: 90vh;
			display: flex;
			align-items: center;
			justify-content: center;
		}
		
		.image-preview-content img {
			max-width: 100%;
			max-height: 100%;
			object-fit: contain;
			border-radius: 8px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
			cursor: default;
		}
		
		.image-preview-close {
			position: absolute;
			top: 20px;
			right: 20px;
			background: rgba(255, 255, 255, 0.9);
			border: none;
			border-radius: 50%;
			width: 50px;
			height: 50px;
			font-size: 24px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: all 0.2s ease;
			color: #333;
			line-height: 50px;
			font-weight: bold;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
		}
		
		.image-preview-close:hover {
			background: rgba(255, 255, 255, 1);
			transform: scale(1.1);
			box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
		}
	</style>
	</head>
	<body>
		<!-- å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† -->
		<div id="image-preview-modal" class="image-preview-modal">
			<div class="image-preview-content">
				<img id="preview-image" src="" alt="é¢„è§ˆå›¾ç‰‡" />
				<button class="image-preview-close" id="close-preview">Ã—</button>
				<div class="image-preview-info" id="preview-info">å›¾ç‰‡ä¿¡æ¯</div>
			</div>
		</div>
		
		<!-- è®¾ç½®æ¨¡æ€æ¡† -->
		<div id="settings-modal" class="settings-modal">
			<div class="settings-content" style="width: 500px;">
				<div class="settings-header">
					<h3 class="settings-title">è®¾ç½®</h3>
					<button class="close-btn" id="close-settings">Ã—</button>
				</div>
				<div class="form-group">
					<label for="provider-select">æ¨¡å‹å‚å•†</label>
					<select id="provider-select">
						<option value="qwen">é€šä¹‰åƒé—®</option>
						<option value="zhipu">æ™ºè°±AI</option>
						<option value="custom">è‡ªå®šä¹‰</option>
					</select>
				</div>
				<div class="form-group" id="model-group">
					<label for="model-select">é€‰æ‹©æ¨¡å‹</label>
					<select id="model-select">
						<option value="qwen3-vl-plus" selected>qwen3-vl-plus</option>
						<option value="qwen-vl-max-latest">qwen-vl-max-latest</option>
						<option value="qwen2.5-vl-7b-instruct">qwen2.5-vl-7b-instruct</option>
						<option value="qwen2.5-vl-72b-instruct">qwen2.5-vl-72b-instruct</option>
						<option value="qvq-72b-preview">qvq-72b-preview</option>
					</select>
				</div>
				<div class="form-group" id="api-key-group">
					<label for="api-key">APIå¯†é’¥</label>
					<input type="text" id="api-key" placeholder="è¯·è¾“å…¥æ‚¨çš„APIå¯†é’¥" />
				</div>
				<div class="form-group" id="api-url-group" style="display: none;">
					<label for="api-url">APIåœ°å€</label>
					<input type="text" id="api-url" placeholder="è¯·è¾“å…¥APIåœ°å€" />
				</div>
				<div class="form-group" id="custom-model-group" style="display: none;">
					<label for="custom-model">æ¨¡å‹åç§°</label>
					<input type="text" id="custom-model" placeholder="è¯·è¾“å…¥æ¨¡å‹åç§°" />
				</div>
				<div style="display: flex; justify-content: flex-end; gap: 12px; margin-top: 24px;">
					<button type="button" id="cancel-settings" style="background: #e9ecef; color: #495057;">å–æ¶ˆ</button>
					<button type="button" id="save-settings" class="btn-primary">ä¿å­˜</button>
				</div>
			</div>
		</div>

		<div class="container">
			<!-- å·¦ä¾§é¢æ¿ -->
			<div class="left-panel">
				<div class="header">
					<h1>å°è£…ç”Ÿæˆå™¨</h1>
					<button class="settings-btn" id="open-settings">è®¾ç½®</button>
				</div>
				
				<!-- ä¸Šä¼ åŒºåŸŸ -->
				<div class="upload-section">
					<div id="drop-area" class="upload-area">
						<p>æ‹–æ‹½PDFæˆ–å›¾ç‰‡åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ </p>
						<input type="file" id="file-input" multiple accept=".pdf,image/*" style="display: none" />
					</div>
				</div>

				<!-- æ§åˆ¶åŒºåŸŸ -->
				<div class="controls-section">
					<div class="control-row single-row">
						<div class="control-buttons">
							<button id="search-position" class="btn-primary" disabled>æœç´¢å°è£…ä½ç½®</button>
							<button id="extract-params" class="btn-success" disabled>æå–å‚æ•°</button>
							<button id="clear-selection">æ¸…é™¤æ¡†é€‰</button>
							<button id="manual-select">æ‰‹åŠ¨æ¡†é€‰</button>
							<button class="btn-secondary" id="hideButton">éšè—çª—å£</button>
							<button class="settings-btn" id="open-settings-control">è®¾ç½®</button>
						</div>
						<div class="timing-display" id="timing-display">è€—æ—¶: --</div>
					</div>
					<div class="progress-container">
						<div class="coordinate-display" id="coordinate-display">
							åæ ‡ä¿¡æ¯: æœªé€‰æ‹©åŒºåŸŸ
						</div>
						<div class="progress-bar" id="progress-bar">
							<div class="progress-fill" id="progress-fill"></div>
						</div>
						<div class="progress-text" id="progress-text"></div>
					</div>
				</div>

				<!-- å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸ -->
				<div class="image-display" id="image-display">
					<div class="selection-overlay" id="selection-overlay"></div>
					<div class="empty-state">è¯·ä¸Šä¼ PDFæˆ–å›¾ç‰‡æ–‡ä»¶</div>
					<input type="file" id="file-input" multiple accept=".pdf,image/*" style="display: none" />
				</div>

				<!-- å›¾ç‰‡å¯¼èˆªåŒºåŸŸ -->
				<div class="image-navigation" id="image-navigation" style="display: none;">
					<div class="nav-controls">
					<button id="prev-image" class="nav-btn">â€¹ ä¸Šä¸€å¼ </button>
						<input type="number" id="page-input" min="1" value="1" placeholder="é¡µç " title="è¾“å…¥é¡µç æŒ‰å›è½¦é”®å¿«é€Ÿè·³è½¬åˆ°æŒ‡å®šé¡µé¢" style="width: 40px; text-align: center; border: 1px solid #ddd; background: white; font-size: 12px; font-weight: 500; color: #495057; border-radius: 3px; padding: 1px 2px;" /> / <span id="total-pages">1</span>
					</span>
					<button id="next-image" class="nav-btn">ä¸‹ä¸€å¼  â€º</button>
				</div>
					<div class="image-info" id="image-info">å½“å‰å›¾ç‰‡</div>
				</div>
			</div>

			<!-- å³ä¾§é¢æ¿ -->
			<div class="right-panel">
				<div class="pin-table-section">
					<div class="table-controls">
						<button id="add-param">æ·»åŠ å‚æ•°</button>
						<button id="clear-table">æ¸…ç©ºè¡¨æ ¼</button>
						<button id="create-footprint" class="btn-success">åˆ›å»ºå°è£…</button>
						<select id="package-type-select" style="width: 120px; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; font-size: 12px; background: #ffffff; margin-left: 8px;">
							<option value="">å°è£…ç±»å‹</option>
							<option value="BGA">BGA</option>
							<option value="DIP">DIP</option>
							<option value="QFN">QFN</option>
							<option value="QFP">QFP</option>
							<option value="SOP">SOP</option>
							<option value="SOD">SOD</option>
							<option value="SOT23">SOT23</option>
							<option value="SOT223">SOT223</option>
						</select>
					</div>
					<div class="pin-table-content">
						<div id="pin-table-container">
							<div class="empty-state">æš‚æ— å¼•è„šä¿¡æ¯</div>
						</div>
					</div>
				</div>
			</div>

		</div>

		<script>
			// è®¾ç½®PDF.jsçš„workerè·¯å¾„
			pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

			// å…¨å±€å˜é‡
			let uploadedFiles = [];
			let currentImages = [];
			let currentImageIndex = 0;
			let apiKey = '';
			let selectedModel = 'qwen3-vl-plus';
			let selectedProvider = 'qwen';
			let apiUrl = '';
			let customApiUrl = '';
			let customModel = '';
			let isSelecting = false;
			let selectionStart = { x: 0, y: 0 };
			let selectionEnd = { x: 0, y: 0 };
			let selectionBox = null;
			let currentSelection = null;
			let paramData = [];
			let detectionResults = null;

			// æ£€æµ‹æ˜¯å¦ä½¿ç”¨ç‰¹æ®ŠAPIæ ¼å¼çš„è¾…åŠ©å‡½æ•°
			function isSpecialApiFormat(provider, url) {
				return provider === 'custom' && url && url.includes('/ai-chat-api/complete');
			}
			let processedImages = [];
			let imageSelections = {}; // å­˜å‚¨æ¯å¼ å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
			let startTime = null; // è®¡æ—¶å¼€å§‹æ—¶é—´
			let timingInterval = null; // è®¡æ—¶å™¨é—´éš”
			const modelRates = {
				'qwen-vl-max-latest': { input: 0.003, output: 0.009 },
				'qwen2.5-vl-7b-instruct': { input: 0.002, output: 0.005 },
				'qwen2.5-vl-72b-instruct': { input: 0.016, output: 0.048 },
				'qvq-72b-preview': { input: 0.012, output: 0.036 },
				'qwen3-vl-plus': { input: 0.0015, output: 0.0045 },
			};

			// æ¨¡å‹å‚å•†é…ç½®
			const providerConfigs = {
				qwen: {
					name: 'é€šä¹‰åƒé—®',
					apiUrl: 'https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions',
					models: [
						{ value: 'qwen3-vl-plus', name: 'qwen3-vl-plus' },
						{ value: 'qwen-vl-max-latest', name: 'qwen-vl-max-latest' },
						{ value: 'qwen2.5-vl-7b-instruct', name: 'qwen2.5-vl-7b-instruct' },
						{ value: 'qwen2.5-vl-72b-instruct', name: 'qwen2.5-vl-72b-instruct' },
						{ value: 'qvq-72b-preview', name: 'qvq-72b-preview' }
					],
					requiresApiKey: true
				},
				zhipu: {
					name: 'æ™ºè°±AI',
					apiUrl: 'https://open.bigmodel.cn/api/paas/v4/chat/completions',
					models: [
						{ value: 'glm-4.5v', name: 'GLM-4.5V' }
					],
					requiresApiKey: true
				},
				custom: {
					name: 'è‡ªå®šä¹‰',
					apiUrl: '',
					models: [],
					requiresApiKey: false
				}
			};

			// å°è£…ç±»å‹å‚æ•°é…ç½®
			const packageParams = {
				'BGA': [
					{ name: 'å¼•è„šè¡Œæ•°', key: 'pin_rows', unit: '' },
					{ name: 'å¼•è„šåˆ—æ•°', key: 'pin_cols', unit: '' },
					{ name: 'æœ¬ä½“é•¿åº¦(BL)', key: 'body_length', unit: 'mm' },
					{ name: 'æœ¬ä½“å®½åº¦(BW)', key: 'body_width', unit: 'mm' },
					{ name: 'å¼•è„šç›´å¾„(PD)', key: 'pin_diameter', unit: 'mm' },
					{ name: 'å¼•è„šé—´è·(PS)', key: 'pin_spacing', unit: 'mm' },
					{ name: 'å¼•è„šçºµå‘é—´è·(PP)', key: 'pin_pitch', unit: 'mm' }
				],
				'DIP': [
				{ name: 'å¼•è„šæ•°é‡', key: 'pin_count', unit: '' },
				{ name: 'å¼•è„šè·¨è·', key: 'LS', unit: 'mm' },
				{ name: 'æœ¬ä½“é•¿åº¦', key: 'BL', unit: 'mm' },
				{ name: 'æœ¬ä½“å®½åº¦', key: 'BW', unit: 'mm' },
				{ name: 'å¼•è„šç›´å¾„', key: 'PD', unit: 'mm' },
				{ name: 'å¼•è„šé—´è·', key: 'PS', unit: 'mm' }
			],
				'QFN': [
					{ name: 'å¼•è„šæ•°(å·¦å³)', key: 'pin_count_lr', unit: '' },
					{ name: 'å¼•è„šæ•°(ä¸Šä¸‹)', key: 'pin_count_tb', unit: '' },
					{ name: 'æœ¬ä½“é•¿åº¦(BL)', key: 'body_length', unit: 'mm' },
					{ name: 'æœ¬ä½“å®½åº¦(BW)', key: 'body_width', unit: 'mm' },
					{ name: 'å¼•è„šé•¿åº¦(PL)', key: 'pin_length', unit: 'mm' },
					{ name: 'å¼•è„šå®½åº¦(PW)', key: 'pin_width', unit: 'mm' },
					{ name: 'å¼•è„šé—´è·(PP)', key: 'pin_pitch', unit: 'mm' }
				],
				'QFP': [
					{ name: 'å¼•è„šæ•°(å·¦å³)', key: 'pin_count_lr', unit: '' },
					{ name: 'å¼•è„šæ•°(ä¸Šä¸‹)', key: 'pin_count_tb', unit: '' },
					{ name: 'å¼•è„šè·¨è·(LS1)', key: 'lead_span1', unit: 'mm' },
					{ name: 'å¼•è„šçºµå‘è·¨è·(LS2)', key: 'lead_span2', unit: 'mm' },
					{ name: 'æœ¬ä½“é•¿åº¦(BL)', key: 'body_length', unit: 'mm' },
					{ name: 'æœ¬ä½“å®½åº¦(BW)', key: 'body_width', unit: 'mm' },
					{ name: 'å¼•è„šé•¿åº¦(PL)', key: 'pin_length', unit: 'mm' },
					{ name: 'å¼•è„šå®½åº¦(PW)', key: 'pin_width', unit: 'mm' },
					{ name: 'å¼•è„šé—´è·(PP)', key: 'pin_pitch', unit: 'mm' }
				],
				'SOD': [
					{ name: 'å¼•è„šè·¨è·(LS)', key: 'lead_span', unit: 'mm' },
					{ name: 'æœ¬ä½“é•¿åº¦(BL)', key: 'body_length', unit: 'mm' },
					{ name: 'æœ¬ä½“å®½åº¦(BW)', key: 'body_width', unit: 'mm' },
					{ name: 'å¼•è„šé•¿åº¦(PL)', key: 'pin_length', unit: 'mm' },
					{ name: 'å¼•è„šå®½åº¦(PW)', key: 'pin_width', unit: 'mm' }
				],
				'SOT23': [
					{ name: 'å¼•è„šæ•°é‡', key: 'pin_count', unit: '' },
					{ name: 'å¼•è„šè·¨è·(LS)', key: 'lead_span', unit: 'mm' },
					{ name: 'æœ¬ä½“é•¿åº¦(BL)', key: 'body_length', unit: 'mm' },
					{ name: 'æœ¬ä½“å®½åº¦(BW)', key: 'body_width', unit: 'mm' },
					{ name: 'å¼•è„šé•¿åº¦(PL)', key: 'pin_length', unit: 'mm' },
					{ name: 'å¼•è„šå®½åº¦(PW)', key: 'pin_width', unit: 'mm' },
					{ name: 'å¼•è„šé—´è·(PP)', key: 'pin_pitch', unit: 'mm' }
				],
				'SOT223': [
					{ name: 'å¼•è„šæ•°é‡', key: 'pin_count', unit: '' },
					{ name: 'å¼•è„šè·¨è·(LS)', key: 'lead_span', unit: 'mm' },
					{ name: 'æœ¬ä½“é•¿åº¦(BL)', key: 'body_length', unit: 'mm' },
					{ name: 'æœ¬ä½“å®½åº¦(BW)', key: 'body_width', unit: 'mm' },
					{ name: 'å¼•è„šé•¿åº¦(PL)', key: 'pin_length', unit: 'mm' },
					{ name: 'å¼•è„šå®½åº¦(PW)', key: 'pin_width', unit: 'mm' },
					{ name: 'å¼•è„šé—´è·(PS)', key: 'pin_spacing', unit: 'mm' },
					{ name: 'å¼•è„šå®½åº¦(PW1)', key: 'pin_width1', unit: 'mm' }
				]
			};

			// DOMå…ƒç´ 
			const dropArea = document.getElementById('image-display');
			const fileInput = document.getElementById('file-input');
			const imageDisplay = document.getElementById('image-display');
			const coordinateDisplay = document.getElementById('coordinate-display');
			const clearSelectionButton = document.getElementById('clear-selection');
			const searchPositionButton = document.getElementById('search-position');
			const extractParamsButton = document.getElementById('extract-params');
			const manualSelectButton = document.getElementById('manual-select');
			const hideButton = document.getElementById('hideButton');
			let selectionOverlay = document.getElementById('selection-overlay');
			const settingsModal = document.getElementById('settings-modal');
			const openSettingsBtn = document.getElementById('open-settings');
			const closeSettingsBtn = document.getElementById('close-settings');
			const cancelSettingsBtn = document.getElementById('cancel-settings');
			const saveSettingsBtn = document.getElementById('save-settings');
			const apiKeyInput = document.getElementById('api-key');
			const providerSelect = document.getElementById('provider-select');
			const modelSelect = document.getElementById('model-select');
			const apiKeyGroup = document.getElementById('api-key-group');
			const modelGroup = document.getElementById('model-group');
			const apiUrlInput = document.getElementById('api-url');
			const customModelInput = document.getElementById('custom-model');
			const customUrlGroup = document.getElementById('api-url-group');
			const customModelGroup = document.getElementById('custom-model-group');
			const packageTypeSelect = document.getElementById('package-type-select');
			const addParamButton = document.getElementById('add-param');
			const clearTableButton = document.getElementById('clear-table');
			const createFootprintButton = document.getElementById('create-footprint');
			const pinTableContainer = document.getElementById('pin-table-container');
			const imageNavigation = document.getElementById('image-navigation');
			const prevImageBtn = document.getElementById('prev-image');
			const nextImageBtn = document.getElementById('next-image');
			const imageCounter = document.getElementById('image-counter');
			const imageInfo = document.getElementById('image-info');
			const progressBar = document.getElementById('progress-bar');
			const progressFill = document.getElementById('progress-fill');
			const progressText = document.getElementById('progress-text');
			const timingDisplay = document.getElementById('timing-display');

			// åˆå§‹åŒ–
			document.addEventListener('DOMContentLoaded', function () {
				// EDAå…¼å®¹æ€§æ£€æŸ¥
				if (typeof eda === 'undefined') {
					window.eda = {
						sys_Storage: {
							getExtensionUserConfig: function(key) {
								return localStorage.getItem('eda_' + key);
							},
							setExtensionUserConfig: function(key, value) {
								localStorage.setItem('eda_' + key, value);
							}
						},
						sch_PrimitivePin: {
							create: function() {
								console.log('EDAç¯å¢ƒä¸å¯ç”¨ï¼Œæ— æ³•åˆ›å»ºå¼•è„š');
								return null;
							}
						}
					};
				}

				// åˆå§‹åŒ–å…¨å±€å˜é‡
				apiKey = eda.sys_Storage.getExtensionUserConfig('api_key') || '';
				selectedProvider = eda.sys_Storage.getExtensionUserConfig('selected_provider') || 'qwen';
				selectedModel = eda.sys_Storage.getExtensionUserConfig('selected_model') || 'qwen3-vl-plus';
				apiUrl = eda.sys_Storage.getExtensionUserConfig('api_url') || '';
				customApiUrl = eda.sys_Storage.getExtensionUserConfig('custom_api_url') || '';
				customModel = eda.sys_Storage.getExtensionUserConfig('custom_model') || '';

				// åŠ è½½è®¾ç½®
				loadSettings();
				updateModelOptions();

				// è®¾ç½®æ¨¡æ€æ¡†äº‹ä»¶å¤„ç†
			openSettingsBtn.addEventListener('click', function() {
				settingsModal.style.display = 'flex';
			});

			// æ§åˆ¶åŒºåŸŸè®¾ç½®æŒ‰é’®äº‹ä»¶å¤„ç†
			const openSettingsControlBtn = document.getElementById('open-settings-control');
			if (openSettingsControlBtn) {
				openSettingsControlBtn.addEventListener('click', function() {
					settingsModal.style.display = 'flex';
				});
			}

				closeSettingsBtn.addEventListener('click', function() {
					settingsModal.style.display = 'none';
				});

				cancelSettingsBtn.addEventListener('click', function() {
					settingsModal.style.display = 'none';
				});

				// æœåŠ¡å•†é€‰æ‹©å˜åŒ–äº‹ä»¶
				providerSelect.addEventListener('change', function() {
					selectedProvider = providerSelect.value;
					updateModelOptions();
				});

				saveSettingsBtn.addEventListener('click', function() {
					saveSettings();
					
					// å…³é—­æ¨¡æ€æ¡†
					settingsModal.style.display = 'none';

					// æ˜¾ç¤ºä¿å­˜æˆåŠŸæç¤º
					eda.sys_ToastMessage.showMessage('è®¾ç½®å·²ä¿å­˜ï¼', 1);
				});

				// ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
				window.addEventListener('click', function(event) {
					if (event.target === settingsModal) {
						settingsModal.style.display = 'none';
					}
				});

				// åˆå§‹åŒ–æ‹–æ”¾åŒºåŸŸ
				initDropArea();
				initButtons();
				initImageSelection();
				initImageNavigation();
				initManualSelection();
				updateParamTable();
				updateUI();
				updateButtons();
			});

			/**
			 * æ›´æ–°æ¨¡å‹é€‰é¡¹
			 */
			function updateModelOptions() {
				const provider = selectedProvider;
				const config = providerConfigs[provider];
				
				// æ¸…ç©ºç°æœ‰é€‰é¡¹
				modelSelect.innerHTML = '';
				
				if (provider === 'custom') {
				// è‡ªå®šä¹‰æ¨¡å¼ï¼šæ˜¾ç¤ºAPIå¯†é’¥ã€è‡ªå®šä¹‰URLå’Œæ¨¡å‹ï¼Œéšè—é¢„è®¾æ¨¡å‹é€‰æ‹©
				apiKeyGroup.style.display = 'block';
				modelGroup.style.display = 'none';
				customUrlGroup.style.display = 'block';
				customModelGroup.style.display = 'block';
					
					// æ¢å¤APIåœ°å€è¾“å…¥æ¡†çš„å¯ç¼–è¾‘çŠ¶æ€
				apiUrlInput.readOnly = false;
				apiUrlInput.style.backgroundColor = '';
				apiUrlInput.style.cursor = '';
				
				// è‡ªå®šä¹‰æ¨¡å¼ä¸‹ç”¨æˆ·éœ€è¦æ‰‹åŠ¨è¾“å…¥APIåœ°å€
				} else {
					// å…¶ä»–æ¨¡å¼ï¼šæ˜¾ç¤ºç›¸åº”çš„UIå…ƒç´ 
					apiKeyGroup.style.display = config.requiresApiKey ? 'block' : 'none';
					modelGroup.style.display = 'block';
					customUrlGroup.style.display = 'none';
					customModelGroup.style.display = 'none';
					
					// æ¢å¤APIåœ°å€è¾“å…¥æ¡†çš„å¯ç¼–è¾‘çŠ¶æ€
					apiUrlInput.readOnly = false;
					apiUrlInput.style.backgroundColor = '';
					apiUrlInput.style.cursor = '';
					
					// æ·»åŠ æ¨¡å‹é€‰é¡¹
					config.models.forEach(model => {
						const option = document.createElement('option');
						option.value = model.value;
						option.textContent = model.name;
						modelSelect.appendChild(option);
					});
					
					// è®¾ç½®å½“å‰é€‰ä¸­çš„æ¨¡å‹
					if (selectedModel && config.models.some(m => m.value === selectedModel)) {
						modelSelect.value = selectedModel;
					} else if (config.models.length > 0) {
						modelSelect.value = config.models[0].value;
						selectedModel = config.models[0].value;
					}
				}
			}
			
			/**
			 * åŠ è½½è®¾ç½®
			 */
			function loadSettings() {
				apiKeyInput.value = apiKey;
				providerSelect.value = selectedProvider;
				apiUrlInput.value = apiUrl;
				customModelInput.value = customModel;
			}
			
			/**
			 * ä¿å­˜è®¾ç½®
			 */
			function saveSettings() {
				apiKey = apiKeyInput.value;
				selectedProvider = providerSelect.value;
				selectedModel = modelSelect.value;
				apiUrl = apiUrlInput.value;
				customModel = customModelInput.value;
				
				eda.sys_Storage.setExtensionUserConfig('api_key', apiKey);
				eda.sys_Storage.setExtensionUserConfig('selected_provider', selectedProvider);
				eda.sys_Storage.setExtensionUserConfig('selected_model', selectedModel);
				eda.sys_Storage.setExtensionUserConfig('api_url', apiUrl);
				eda.sys_Storage.setExtensionUserConfig('custom_model', customModel);
			}

			/**
			 * åˆå§‹åŒ–æ‹–æ”¾åŒºåŸŸçš„äº‹ä»¶ç›‘å¬
			 */
			function initDropArea() {
				['dragenter', 'dragover', 'dragleave', 'drop'].forEach((eventName) => {
					dropArea.addEventListener(eventName, preventDefaults, false);
				});

				['dragenter', 'dragover'].forEach((eventName) => {
					dropArea.addEventListener(eventName, highlight, false);
				});

				['dragleave', 'drop'].forEach((eventName) => {
					dropArea.addEventListener(eventName, unhighlight, false);
				});

				dropArea.addEventListener('drop', handleDrop, false);
				dropArea.addEventListener('click', () => {
					// åªæœ‰åœ¨æ²¡æœ‰å›¾ç‰‡æ—¶æ‰è§¦å‘æ–‡ä»¶é€‰æ‹©ï¼Œé¿å…å¹²æ‰°å›¾ç‰‡ç‚¹å‡»é¢„è§ˆ
					if (currentImages.length === 0) {
						fileInput.click();
					}
				});

				fileInput.addEventListener('change', handleFiles, false);
			}

			/**
			 * é˜»æ­¢é»˜è®¤æ‹–æ”¾è¡Œä¸º
			 */
			function preventDefaults(e) {
				e.preventDefault();
				e.stopPropagation();
			}

			/**
			 * é«˜äº®æ˜¾ç¤ºæ‹–æ”¾åŒºåŸŸ
			 */
			function highlight() {
				dropArea.classList.add('highlight');
			}

			/**
			 * å–æ¶ˆé«˜äº®æ˜¾ç¤º
			 */
			function unhighlight() {
				dropArea.classList.remove('highlight');
			}

			/**
			 * å¤„ç†æ‹–æ”¾çš„æ–‡ä»¶
			 */
			function handleDrop(e) {
				const dt = e.dataTransfer;
				const files = dt.files;
				handleFiles({ target: { files } });
			}

			/**
			 * å¤„ç†æ–‡ä»¶ä¸Šä¼ 
			 */
			async function handleFiles(e) {
				let files = [];
				if (e.dataTransfer) {
					files = e.dataTransfer.files;
				} else if (e.target && e.target.files) {
					files = e.target.files;
				}

				if (files.length === 0) return;

				for (let i = 0; i < files.length; i++) {
					const file = files[i];
					
					if (file.type === 'application/pdf') {
						// å¤„ç†PDFæ–‡ä»¶
						await processPDF(file);
					} else if (file.type.match('image.*')) {
						// å¤„ç†å›¾ç‰‡æ–‡ä»¶
						await processImage(file);
					} else {
						eda.sys_ToastMessage.showMessage(`æ–‡ä»¶ "${file.name}" æ ¼å¼ä¸æ”¯æŒï¼Œè¯·ä¸Šä¼ PDFæˆ–å›¾ç‰‡æ–‡ä»¶`, 2);
						continue;
					}
				}

				updateUI();
			}

			/**
			 * æ˜¾ç¤ºè¿›åº¦æ¡
			 */
			function showProgress() {
				progressBar.style.display = 'block';
				progressText.style.display = 'block';
			}

			/**
			 * éšè—è¿›åº¦æ¡
			 */
			function hideProgress() {
				progressBar.style.display = 'none';
				progressText.style.display = 'none';
				progressFill.style.width = '0%';
			}

			/**
			 * æ›´æ–°è¿›åº¦
			 */
			function updateProgress(percentage, text) {
				progressFill.style.width = percentage + '%';
				progressText.textContent = text;
			}

			/**
			 * å¤„ç†PDFæ–‡ä»¶
			 */
			async function processPDF(file) {
				try {
					// é‡æ–°å¯¼å…¥PDFæ—¶æ¸…é™¤ä¹‹å‰çš„æ•°æ®
					currentImages = [];
					imageSelections = {};
					detectionResults = null;
					clearSelection();
					
					// æ˜¾ç¤ºè¿›åº¦æ¡
					showProgress();
					updateProgress(0, 'å¼€å§‹è§£æPDF...');
					
					const arrayBuffer = await file.arrayBuffer();
					const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
					
					for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
						const progress = Math.round((pageNum / pdf.numPages) * 100);
						updateProgress(progress, `æ­£åœ¨è½¬æ¢ç¬¬ ${pageNum}/${pdf.numPages} é¡µ...`);
						
						const page = await pdf.getPage(pageNum);
						const viewport = page.getViewport({ scale: 1.0 });
						
						const canvas = document.createElement('canvas');
						const context = canvas.getContext('2d');
						canvas.height = viewport.height;
						canvas.width = viewport.width;
						
						await page.render({ canvasContext: context, viewport: viewport }).promise;
						
						const imageData = canvas.toDataURL('image/png');
				currentImages.push({
					src: imageData,
					name: `${file.name} - ç¬¬${pageNum}é¡µ`,
					type: 'pdf-page',
					file: file
				});
					}
					
					updateProgress(100, `PDFè§£æå®Œæˆï¼Œå…±${pdf.numPages}é¡µ`);
					
					if (currentImages.length > 0) {
						currentImageIndex = 0;
						displayCurrentImage();
					}
					
					// å»¶è¿Ÿéšè—è¿›åº¦æ¡
					setTimeout(() => {
						hideProgress();
					}, 1500);
					
					eda.sys_ToastMessage.showMessage(`PDFè§£æå®Œæˆï¼Œå…±${pdf.numPages}é¡µ`, 1);
				} catch (error) {
					console.error('PDFå¤„ç†å¤±è´¥:', error);
					hideProgress();
					eda.sys_ToastMessage.showMessage('PDFå¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼', 0);
				}
			}

			/**
			 * å¤„ç†å›¾ç‰‡æ–‡ä»¶
			 */
			async function processImage(file) {
				return new Promise((resolve) => {
					const reader = new FileReader();
					reader.onload = function (e) {
					currentImages.push({
						src: e.target.result,
						name: file.name,
						type: 'image',
						file: file
					});
						
						if (currentImages.length === 1) {
							currentImageIndex = 0;
							displayCurrentImage();
						}
						
						resolve();
					};
					reader.readAsDataURL(file);
				});
			}

			/**
			 * ä¿å­˜å½“å‰å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
			 */
			function saveCurrentImageSelection() {
				if (currentImages.length === 0 || !selectionOverlay) return;
				
				const imageKey = `image_${currentImageIndex}`;
				const selections = [];
				
				// ä¿å­˜æ‰‹åŠ¨é€‰æ‹©æ¡†
				const selectionBoxes = selectionOverlay.querySelectorAll('.selection-box');
				selectionBoxes.forEach(box => {
					selections.push({
						type: 'manual',
						left: box.style.left,
						top: box.style.top,
						width: box.style.width,
						height: box.style.height,
						border: box.style.border,
						backgroundColor: box.style.backgroundColor
					});
				});
				
				// ä¿å­˜æ£€æµ‹æ¡†
				const detectionBoxes = selectionOverlay.querySelectorAll('.detection-box');
				detectionBoxes.forEach(box => {
					const label = box.querySelector('.detection-label');
					selections.push({
						type: 'detection',
						left: box.style.left,
						top: box.style.top,
						width: box.style.width,
						height: box.style.height,
						labelText: label ? label.textContent : ''
					});
				});
				
				imageSelections[imageKey] = selections;
				console.log(`ä¿å­˜å›¾ç‰‡ ${currentImageIndex + 1} çš„æ¡†é€‰çŠ¶æ€:`, selections);
			}
			
			/**
			 * æ¢å¤å½“å‰å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
			 */
			function restoreCurrentImageSelection() {
				if (currentImages.length === 0 || !selectionOverlay) return;
				
				const imageKey = `image_${currentImageIndex}`;
				const selections = imageSelections[imageKey];
				
				if (!selections || selections.length === 0) {
					console.log(`å›¾ç‰‡ ${currentImageIndex + 1} æ²¡æœ‰ä¿å­˜çš„æ¡†é€‰çŠ¶æ€`);
					return;
				}
				
				console.log(`æ¢å¤å›¾ç‰‡ ${currentImageIndex + 1} çš„æ¡†é€‰çŠ¶æ€:`, selections);
				
				selections.forEach(selection => {
					if (selection.type === 'manual') {
						// æ¢å¤æ‰‹åŠ¨é€‰æ‹©æ¡†
						const selectionBox = document.createElement('div');
						selectionBox.className = 'selection-box';
						selectionBox.style.position = 'absolute';
						selectionBox.style.left = selection.left;
						selectionBox.style.top = selection.top;
						selectionBox.style.width = selection.width;
						selectionBox.style.height = selection.height;
						selectionBox.style.border = selection.border;
						selectionBox.style.backgroundColor = selection.backgroundColor;
						selectionBox.style.zIndex = '12';
						selectionOverlay.appendChild(selectionBox);
					} else if (selection.type === 'detection') {
						// æ¢å¤æ£€æµ‹æ¡†
						const detectionBox = document.createElement('div');
						detectionBox.className = 'detection-box';
						detectionBox.style.position = 'absolute';
						detectionBox.style.left = selection.left;
						detectionBox.style.top = selection.top;
						detectionBox.style.width = selection.width;
						detectionBox.style.height = selection.height;
						detectionBox.style.border = '2px solid #e74c3c';
						detectionBox.style.backgroundColor = 'rgba(231, 76, 60, 0.2)';
						detectionBox.style.zIndex = '11';
						
						if (selection.labelText) {
							const label = document.createElement('div');
							label.className = 'detection-label';
							label.textContent = selection.labelText;
							detectionBox.appendChild(label);
						}
						
						selectionOverlay.appendChild(detectionBox);
					}
				});
				
				// æ›´æ–°åæ ‡æ˜¾ç¤ºï¼ˆå¦‚æœæœ‰æ‰‹åŠ¨é€‰æ‹©æ¡†ï¼‰
				const manualSelections = selections.filter(s => s.type === 'manual');
				if (manualSelections.length > 0) {
					const lastSelection = manualSelections[manualSelections.length - 1];
					const left = parseInt(lastSelection.left);
					const top = parseInt(lastSelection.top);
					const width = parseInt(lastSelection.width);
					const height = parseInt(lastSelection.height);
					updateCoordinateDisplay(left, top, width, height);
				}
			}
			
			/**
			 * æ˜¾ç¤ºå½“å‰å›¾ç‰‡
			 */
			function displayCurrentImage() {
				// æ³¨æ„ï¼šæ¡†é€‰çŠ¶æ€çš„ä¿å­˜ç°åœ¨åœ¨å›¾ç‰‡åˆ‡æ¢æ—¶è¿›è¡Œï¼Œè€Œä¸æ˜¯åœ¨è¿™é‡Œ
				
				if (currentImages.length === 0) {
					imageDisplay.innerHTML = '<div class="empty-state">è¯·ä¸Šä¼ PDFæˆ–å›¾ç‰‡æ–‡ä»¶</div>';
					imageNavigation.style.display = 'none';
					// æ¢å¤è™šçº¿è¾¹æ¡†
					imageDisplay.style.border = '2px dashed #ced4da';
					imageDisplay.style.cursor = 'pointer';
					return;
				}
				
				// ç§»é™¤è™šçº¿è¾¹æ¡†ï¼Œå› ä¸ºæœ‰å›¾ç‰‡äº†
				imageDisplay.style.border = 'none';
				imageDisplay.style.cursor = 'default';
				
				const currentImage = currentImages[currentImageIndex];
				
				// åˆ›å»ºå›¾ç‰‡å®¹å™¨
				const imageContainer = document.createElement('div');
				imageContainer.className = 'image-container';
				
				// åˆ›å»ºå›¾ç‰‡å…ƒç´ 
				const img = document.createElement('img');
				img.src = currentImage.src;
				img.alt = currentImage.name;
				img.id = 'current-image';
				
				// åˆ›å»ºé€‰æ‹©æ¡†å…ƒç´ 
				const selectionBox = document.createElement('div');
				selectionBox.className = 'selection-box';
				selectionBox.id = 'selection-box';
				
				// å°†å›¾ç‰‡å’Œé€‰æ‹©æ¡†æ·»åŠ åˆ°å®¹å™¨ä¸­
				imageContainer.appendChild(img);
				imageContainer.appendChild(selectionBox);
				
				// æ¸…ç©ºå¹¶æ·»åŠ æ–°çš„å›¾ç‰‡å®¹å™¨
				imageDisplay.innerHTML = '';
				imageDisplay.appendChild(imageContainer);
				
				// é‡æ–°æ·»åŠ æ›¿æ¢PDFæŒ‰é’®
				const replacePdfOverlay = document.createElement('div');
				replacePdfOverlay.className = 'replace-pdf-overlay';
				replacePdfOverlay.id = 'replace-pdf-overlay';
				const replacePdfBtn = document.createElement('button');
				replacePdfBtn.id = 'replace-pdf-btn';
				replacePdfBtn.textContent = 'æ›¿æ¢PDF';
				replacePdfBtn.addEventListener('click', (e) => {
					e.stopPropagation();
					fileInput.click();
				});
				replacePdfOverlay.appendChild(replacePdfBtn);
				imageDisplay.appendChild(replacePdfOverlay);
				
				// æ˜¾ç¤ºæ›¿æ¢PDFæŒ‰é’®
				replacePdfOverlay.style.display = 'block';
				
				// é‡æ–°æ·»åŠ é€‰æ‹©è¦†ç›–å±‚
			const newSelectionOverlay = document.createElement('div');
			newSelectionOverlay.className = 'selection-overlay';
			newSelectionOverlay.id = 'selection-overlay';
			imageContainer.appendChild(newSelectionOverlay);
			
			// æ›´æ–°å…¨å±€å˜é‡æŒ‡å‘æ–°çš„overlayå…ƒç´ 
			selectionOverlay = newSelectionOverlay;
				
				// æ˜¾ç¤ºå¯¼èˆªåŒºåŸŸ
				imageNavigation.style.display = 'block';
				
				// æ›´æ–°å¯¼èˆªæŒ‰é’®çŠ¶æ€
				prevImageBtn.disabled = currentImageIndex === 0;
				nextImageBtn.disabled = currentImageIndex === currentImages.length - 1;
				
				// æ›´æ–°é¡µç è¾“å…¥æ¡†å’Œæ€»é¡µæ•°æ˜¾ç¤º
				const pageInput = document.getElementById('page-input');
				const totalPages = document.getElementById('total-pages');
				if (pageInput) {
					pageInput.value = currentImageIndex + 1;
					pageInput.max = currentImages.length;
				}
				if (totalPages) {
					totalPages.textContent = currentImages.length;
				}
				
				// æ›´æ–°å›¾ç‰‡ä¿¡æ¯
				if (currentImage.name) {
					imageInfo.textContent = `æ–‡ä»¶: ${currentImage.name}`;
				} else {
					imageInfo.textContent = `é¡µé¢ ${currentImageIndex + 1}`;
				}
				
				// é‡æ–°åˆå§‹åŒ–é€‰æ‹©åŠŸèƒ½
				initImageSelection();
				
				// åˆå§‹åŒ–æ‰‹åŠ¨é€‰æ‹©åŠŸèƒ½
				initManualSelection();
				
				// æ¢å¤æ¡†é€‰çŠ¶æ€æˆ–é‡æ–°ç»˜åˆ¶æ£€æµ‹æ¡†
				if (img.complete && img.naturalWidth > 0) {
					// å…ˆå°è¯•æ¢å¤ä¿å­˜çš„æ¡†é€‰çŠ¶æ€
					restoreCurrentImageSelection();
					// å¦‚æœæœ‰æ£€æµ‹ç»“æœï¼Œæ€»æ˜¯é‡æ–°ç»˜åˆ¶æ£€æµ‹æ¡†ï¼ˆç¡®ä¿æ™ºè°±AIç­‰æ¨¡å‹çš„æ£€æµ‹æ¡†èƒ½æ­£ç¡®æ˜¾ç¤ºï¼‰
					if (detectionResults && detectionResults.pdf_position_list) {
						drawDetectionBoxes();
					}
				} else {
					img.onload = () => {
						// å…ˆå°è¯•æ¢å¤ä¿å­˜çš„æ¡†é€‰çŠ¶æ€
						restoreCurrentImageSelection();
						// å¦‚æœæœ‰æ£€æµ‹ç»“æœï¼Œæ€»æ˜¯é‡æ–°ç»˜åˆ¶æ£€æµ‹æ¡†ï¼ˆç¡®ä¿æ™ºè°±AIç­‰æ¨¡å‹çš„æ£€æµ‹æ¡†èƒ½æ­£ç¡®æ˜¾ç¤ºï¼‰
						if (detectionResults && detectionResults.pdf_position_list) {
							drawDetectionBoxes();
						}
					};
				}
				
				// æ›´æ–°æŒ‰é’®çŠ¶æ€
				updateButtons();
			}

			/**
			 * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
			 */
			function formatFileSize(bytes) {
				if (bytes < 1024) {
					return bytes + ' B';
				} else if (bytes < 1024 * 1024) {
					return (bytes / 1024).toFixed(2) + ' KB';
				} else {
					return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
				}
			}

			/**
			 * åˆå§‹åŒ–å›¾ç‰‡é€‰æ‹©åŠŸèƒ½
			 */
			function initImageSelection() {
				const imageContainer = document.querySelector('.image-container');
				const currentImage = document.getElementById('current-image');
				selectionBox = document.getElementById('selection-box');
				
				if (!imageContainer || !currentImage || !selectionBox) return;
				
				imageContainer.addEventListener('mousedown', startSelection);
				imageContainer.addEventListener('mousemove', updateSelection);
				imageContainer.addEventListener('mouseup', endSelection);
			}
			
			/**
			 * åˆå§‹åŒ–å›¾ç‰‡å¯¼èˆªåŠŸèƒ½
			 */
			function initImageNavigation() {
				if (prevImageBtn) {
					prevImageBtn.addEventListener('click', () => {
						if (currentImageIndex > 0) {
							// å…ˆä¿å­˜å½“å‰å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
							if (selectionOverlay) {
								saveCurrentImageSelection();
							}
							currentImageIndex--;
							displayCurrentImage();
						}
					});
				}
				
				if (nextImageBtn) {
					nextImageBtn.addEventListener('click', () => {
						if (currentImageIndex < currentImages.length - 1) {
							// å…ˆä¿å­˜å½“å‰å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
							if (selectionOverlay) {
								saveCurrentImageSelection();
							}
							currentImageIndex++;
							displayCurrentImage();
						}
					});
				}
				
				// é¡µç è¾“å…¥æ¡†åŠŸèƒ½
				const pageInput = document.getElementById('page-input');
				
				if (pageInput) {
					// é¡µç è·³è½¬åŠŸèƒ½
					pageInput.addEventListener('change', () => {
						const pageNum = parseInt(pageInput.value);
						const imageCounter = document.getElementById('image-counter');
						
						if (pageNum >= 1 && pageNum <= currentImages.length) {
							// å…ˆä¿å­˜å½“å‰å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
							if (selectionOverlay) {
								saveCurrentImageSelection();
							}
							currentImageIndex = pageNum - 1;
							displayCurrentImage();
							
							// è·³è½¬æˆåŠŸçš„è§†è§‰åé¦ˆ
							if (imageCounter) {
								imageCounter.style.backgroundColor = '#d4edda';
								setTimeout(() => {
									imageCounter.style.backgroundColor = '';
								}, 500);
							}
						} else {
							// è¾“å…¥æ— æ•ˆé¡µç æ—¶æ¢å¤å½“å‰é¡µç 
							pageInput.value = currentImageIndex + 1;
							eda.sys_ToastMessage.showMessage(`è¯·è¾“å…¥æœ‰æ•ˆçš„é¡µç  (1-${currentImages.length})`, 0);
							
							// è·³è½¬å¤±è´¥çš„è§†è§‰åé¦ˆ
							if (imageCounter) {
								imageCounter.style.backgroundColor = '#f8d7da';
								setTimeout(() => {
									imageCounter.style.backgroundColor = '';
								}, 500);
							}
						}
					});
					
					// å›è½¦é”®å¿«é€Ÿè·³è½¬
					pageInput.addEventListener('keydown', (e) => {
						if (e.key === 'Enter') {
							e.preventDefault();
							pageInput.dispatchEvent(new Event('change'));
							pageInput.blur();
						}
					});
					
					// ç‚¹å‡»æ—¶é€‰ä¸­æ–‡æœ¬
					pageInput.addEventListener('click', (e) => {
						e.target.select();
					});
				}
				
				// æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
				document.addEventListener('keydown', (e) => {
					if (currentImages.length <= 1) return;
					
					if (e.key === 'ArrowLeft' && currentImageIndex > 0) {
						e.preventDefault();
						// å…ˆä¿å­˜å½“å‰å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
						if (selectionOverlay) {
							saveCurrentImageSelection();
						}
						currentImageIndex--;
						displayCurrentImage();
					} else if (e.key === 'ArrowRight' && currentImageIndex < currentImages.length - 1) {
						e.preventDefault();
						// å…ˆä¿å­˜å½“å‰å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
						if (selectionOverlay) {
							saveCurrentImageSelection();
						}
						currentImageIndex++;
						displayCurrentImage();
					}
				});
			}

			/**
			 * å¼€å§‹é€‰æ‹©
			 */
			function startSelection(e) {
				if (e.target.tagName !== 'IMG') return;
				
				isSelecting = true;
				const rect = e.target.getBoundingClientRect();
				selectionStart.x = e.clientX - rect.left;
				selectionStart.y = e.clientY - rect.top;
				
				selectionBox.style.display = 'block';
				selectionBox.style.left = selectionStart.x + 'px';
				selectionBox.style.top = selectionStart.y + 'px';
				selectionBox.style.width = '0px';
				selectionBox.style.height = '0px';
				
				e.preventDefault();
			}

			/**
			 * æ›´æ–°é€‰æ‹©
			 */
			function updateSelection(e) {
				if (!isSelecting) return;
				
				const rect = e.target.getBoundingClientRect();
				selectionEnd.x = e.clientX - rect.left;
				selectionEnd.y = e.clientY - rect.top;
				
				const left = Math.min(selectionStart.x, selectionEnd.x);
				const top = Math.min(selectionStart.y, selectionEnd.y);
				const width = Math.abs(selectionEnd.x - selectionStart.x);
				const height = Math.abs(selectionEnd.y - selectionStart.y);
				
				selectionBox.style.left = left + 'px';
				selectionBox.style.top = top + 'px';
				selectionBox.style.width = width + 'px';
				selectionBox.style.height = height + 'px';
				
				updateCoordinateDisplay(left, top, width, height);
			}

			/**
			 * ç»“æŸé€‰æ‹©
			 */
			function endSelection(e) {
				isSelecting = false;
			}

			/**
			 * æ›´æ–°åæ ‡æ˜¾ç¤º
			 */
			function updateCoordinateDisplay(x, y, width, height) {
				coordinateDisplay.textContent = `åæ ‡ä¿¡æ¯: X=${Math.round(x)}, Y=${Math.round(y)}, å®½=${Math.round(width)}, é«˜=${Math.round(height)}`;
			}

			/**
			 * åˆå§‹åŒ–æŒ‰é’®äº‹ä»¶
			 */
			function initButtons() {
				// éšè—çª—å£
				hideButton.addEventListener('click', () => {
					eda.sys_IFrame.hideIFrame('footprint');
					eda.sys_ToastMessage.showMessage('é¡µé¢å·²éšè—ï¼Œå¯ç‚¹å‡»ç»§ç»­åˆ›å»ºé‡æ–°æ‰“å¼€é¡µé¢', 0);
				});
				
				// æ¸…é™¤æ¡†é€‰
				clearSelectionButton.addEventListener('click', clearSelection);
				
				// æœç´¢ä½ç½®
				searchPositionButton.addEventListener('click', searchPosition);
				
				// æå–å‚æ•°
				extractParamsButton.addEventListener('click', extractParams);
				
				// æ‰‹åŠ¨æ¡†é€‰
				manualSelectButton.addEventListener('click', toggleManualSelection);
				
				// å°è£…ç±»å‹é€‰æ‹©
				packageTypeSelect.addEventListener('change', onPackageTypeChange);
				
				// æ·»åŠ å‚æ•°
				addParamButton.addEventListener('click', addParam);
				
				// æ¸…ç©ºè¡¨æ ¼
				clearTableButton.addEventListener('click', clearTable);
				
				// åˆ›å»ºå°è£…
				createFootprintButton.addEventListener('click', createFootprintFromTable);
			}

			/**
			 * å¼€å§‹è®¡æ—¶
			 */
			function startTiming() {
				startTime = Date.now();
				timingDisplay.textContent = 'è€—æ—¶: 0.0s';
				
				// æ¸…é™¤ä¹‹å‰çš„è®¡æ—¶å™¨
				if (timingInterval) {
					clearInterval(timingInterval);
				}
				
				// å¼€å§‹å®æ—¶æ›´æ–°è®¡æ—¶æ˜¾ç¤º
				timingInterval = setInterval(() => {
					if (startTime) {
						const elapsed = (Date.now() - startTime) / 1000;
						timingDisplay.textContent = `è€—æ—¶: ${elapsed.toFixed(1)}s`;
					}
				}, 100);
			}
			
			/**
			 * åœæ­¢è®¡æ—¶
			 */
			function stopTiming() {
				if (timingInterval) {
					clearInterval(timingInterval);
					timingInterval = null;
				}
				
				if (startTime) {
					const elapsed = (Date.now() - startTime) / 1000;
					timingDisplay.textContent = `è€—æ—¶: ${elapsed.toFixed(1)}s`;
					startTime = null;
				}
			}
			
			/**
			 * é‡ç½®è®¡æ—¶æ˜¾ç¤º
			 */
			function resetTiming() {
				if (timingInterval) {
					clearInterval(timingInterval);
					timingInterval = null;
				}
				startTime = null;
				timingDisplay.textContent = 'è€—æ—¶: --';
			}
			
			/**
			 */
			async function callCustomAPI(images, prompt) {
				// å°†å›¾ç‰‡è½¬æ¢ä¸ºbase64æ ¼å¼
				const base64Images = [];
				for (let i = 0; i < images.length; i++) {
					// åˆ›å»ºImageå…ƒç´ å¹¶åŠ è½½å›¾ç‰‡
					const img = new Image();
					await new Promise((resolve, reject) => {
						img.onload = resolve;
						img.onerror = reject;
						img.src = images[i].src;
					});
					
					const canvas = document.createElement('canvas');
					const ctx = canvas.getContext('2d');
					canvas.width = img.naturalWidth;
					canvas.height = img.naturalHeight;
					ctx.drawImage(img, 0, 0);
					
					// è½¬æ¢ä¸ºbase64
					const base64 = canvas.toDataURL('image/png');
					base64Images.push(base64);
				}
				
				// è‡ªå®šä¹‰APIæ ¼å¼
				const requestData = {
					type: "chat.user.generic_chat",
					context: {
						chat: {
							input_text: prompt,
							base64_images: base64Images
						},
						history: [],
						messages: []
					}
				};
				
				const headers = {
					'Content-Type': 'application/json',
					'Accept': 'application/json'
				};
				
				// å‘é€è¯·æ±‚
				const response = await eda.sys_ClientUrl.request(
					customApiUrl,
					'POST',
					JSON.stringify(requestData),
					headers
				);
				
				if (!response.ok) {
					const errorText = await response.text();
					console.error('è‡ªå®šä¹‰APIè¯·æ±‚å¤±è´¥:', response.status, errorText);
					throw new Error(`è‡ªå®šä¹‰APIè¯·æ±‚å¤±è´¥: ${response.status} ${errorText}`);
				}
				
				// å…ˆè·å–å“åº”æ–‡æœ¬ï¼Œç„¶åå°è¯•è§£æJSON
				const responseText = await response.text();
				console.log('APIå“åº”:', responseText);
				
				if (!responseText.trim()) {
					throw new Error('è¿”å›ç©ºå“åº”');
				}
				
				let result;
				try {
					// æ¸…ç†å“åº”æ–‡æœ¬ï¼Œç§»é™¤markdownä»£ç å—æ ‡è®°
					let cleanedText = responseText.trim();
					if (cleanedText.startsWith('```json')) {
						cleanedText = cleanedText.replace(/^```json\s*/, '').replace(/\s*```$/, '');
					} else if (cleanedText.startsWith('```')) {
						cleanedText = cleanedText.replace(/^```\s*/, '').replace(/\s*```$/, '');
					}
					result = JSON.parse(cleanedText);
				} catch (parseError) {
					console.error('JSONè§£æå¤±è´¥:', parseError, 'å“åº”å†…å®¹:', responseText);
					throw new Error(`APIå“åº”æ ¼å¼é”™è¯¯: ${parseError.message}`);
				}
				
				// å¤„ç†è‡ªå®šä¹‰APIå“åº”æ ¼å¼
				let content;
				if (result.context && result.context.chat && result.context.chat.input_text) {
					content = result.context.chat.input_text;
				} else if (result.data && result.data.content) {
					content = result.data.content;
				} else if (typeof result === 'object') {
					content = JSON.stringify(result);
				} else {
					content = result.toString();
				}
				
				return content;
			}
			
			/**
			 * æ¸…é™¤æ¡†é€‰
			 */
			function clearSelection() {
				// åœæ­¢æ‰‹åŠ¨é€‰æ‹©æ¨¡å¼
				if (manualSelectionMode) {
					stopManualSelection();
					manualSelectButton.textContent = 'æ‰‹åŠ¨æ¡†é€‰';
				}
				
				// æ¸…é™¤æ—§ç‰ˆé€‰æ‹©æ¡†
				if (selectionBox) {
					selectionBox.style.display = 'none';
				}
				
				// æ¸…é™¤æ£€æµ‹æ¡†å’Œæ‰‹åŠ¨é€‰æ‹©ç›¸å…³å…ƒç´ 
				if (selectionOverlay) {
					const existingBoxes = selectionOverlay.querySelectorAll('.detection-box');
					existingBoxes.forEach(box => box.remove());
					
					// æ¸…é™¤æ‰‹åŠ¨é€‰æ‹©æ¡†
					const selectionBoxes = selectionOverlay.querySelectorAll('.selection-box');
					selectionBoxes.forEach(box => box.remove());
					
					// æ¸…é™¤èµ·ç‚¹æ ‡è®°
					const startMarkers = selectionOverlay.querySelectorAll('.start-marker');
					startMarkers.forEach(marker => marker.remove());
				}
				
				// é‡ç½®é€‰æ‹©çŠ¶æ€
				isSelecting = false;
				manualSelectionMode = false;
				firstPoint = null;
				tempSelectionBox = null;
				selectionStart = { x: 0, y: 0 };
				selectionEnd = { x: 0, y: 0 };
				currentSelection = null;
				
				// æ¸…é™¤å½“å‰å›¾ç‰‡çš„ä¿å­˜çŠ¶æ€
				if (currentImages.length > 0) {
					const imageKey = `image_${currentImageIndex}`;
					delete imageSelections[imageKey];
					console.log(`æ¸…é™¤å›¾ç‰‡ ${currentImageIndex + 1} çš„ä¿å­˜çŠ¶æ€`);
				}
				
				// æ¸…é™¤æ£€æµ‹ç»“æœï¼ˆè¿™æ ·æœç´¢ä½ç½®çš„æ¡†é€‰ä¹Ÿä¼šè¢«æ¸…é™¤ï¼‰
				detectionResults = null;
				console.log('æ¸…é™¤æ£€æµ‹ç»“æœ');
				
				coordinateDisplay.textContent = 'åæ ‡ä¿¡æ¯: æœªé€‰æ‹©åŒºåŸŸ';
				
				// æ›´æ–°æŒ‰é’®çŠ¶æ€
				updateButtons();
			}
			
			/**
			 * æœç´¢ä½ç½® - ç¬¬ä¸€æ­¥ï¼šè¯†åˆ«å°è£…ä½ç½®
			 */
			async function searchPosition() {
				if (currentImages.length === 0) {
					eda.sys_ToastMessage.showMessage('è¯·å…ˆä¸Šä¼ å›¾ç‰‡', 0);
					return;
				}
				
				apiKey = apiKeyInput.value.trim();
			selectedModel = modelSelect.value;
			selectedProvider = providerSelect.value;
			apiUrl = apiUrlInput.value.trim();
			customApiUrl = apiUrlInput.value.trim();
				
				// æ£€æŸ¥æ™ºè°±AIæ¨¡å‹é™åˆ¶
				if (selectedProvider === 'zhipu') {
					eda.sys_ToastMessage.showMessage('æ™ºè°±AIæ¨¡å‹ä¸æ”¯æŒæœç´¢ä½ç½®åŠŸèƒ½ï¼Œè¯¥æ¨¡å‹ä¼ è¾“å›¾ç‰‡æœ‰ä¸Šé™', 0);
					return;
				}
				
				// è‡ªå®šä¹‰APIä¸éœ€è¦APIå¯†é’¥
				if (!isSpecialApiFormat(selectedProvider, apiUrl) && !apiKey) {
					eda.sys_ToastMessage.showMessage('è¯·è¾“å…¥APIå¯†é’¥', 0);
					return;
				}
				
				// ç‰¹æ®ŠAPIä½¿ç”¨é»˜è®¤åœ°å€
				if (isSpecialApiFormat(selectedProvider, apiUrl)) {
				customApiUrl = apiUrl;
				}
				
				eda.sys_Storage.setExtensionUserConfig('api_key', apiKey);
				eda.sys_Storage.setExtensionUserConfig('selected_model', selectedModel);
				eda.sys_Storage.setExtensionUserConfig('selected_provider', selectedProvider);
				eda.sys_Storage.setExtensionUserConfig('custom_api_url', customApiUrl);
				
				try {
				eda.sys_ToastMessage.showMessage('æ­£åœ¨æœç´¢å°è£…ä½ç½®...', 3);
				
				// å¼€å§‹è®¡æ—¶
				startTiming();
				
				if (isSpecialApiFormat(selectedProvider, apiUrl)) {
					// ç‰¹æ®ŠAPIè°ƒç”¨
					const prompt = 'è¯·åˆ†æè¿™äº›å›¾ç‰‡ï¼Œæœç´¢èŠ¯ç‰‡å°è£…çš„åæ ‡ä½ç½®ã€‚ä»¥JSONæ ¼å¼è¾“å‡ºæ‰€æœ‰çš„èŠ¯ç‰‡å°è£…bboxçš„åæ ‡ï¼Œä¸è¦è¾“å‡ºjsonä»£ç æ®µã€‚å¯¹äºæ¯ä¸ªæ£€æµ‹åˆ°çš„å°è£…ï¼Œè¯·è¿”å›ä»¥ä¸‹JSONæ ¼å¼ï¼š\n\n{\n  "input_width": æ¨¡å‹å¤„ç†æ—¶çš„å›¾åƒå®½åº¦,\n  "input_height": æ¨¡å‹å¤„ç†æ—¶çš„å›¾åƒé«˜åº¦,\n  "pdf_position_list": [\n    {\n      "page_num": é¡µç (ä»1å¼€å§‹),\n      "package_type": "å°è£…ç±»å‹(BGA/DIP/QFN/QFP/SOD/SOT23/SOT223)",\n      "confidence": ç½®ä¿¡åº¦(0-1),\n      "package_rect": {\n        "x": xåæ ‡,\n        "y": yåæ ‡,\n        "width": å®½åº¦,\n        "height": é«˜åº¦\n      }\n    }\n  ]\n}\n\næ³¨æ„ï¼šåæ ‡åº”è¯¥åŸºäºæ¨¡å‹å®é™…å¤„ç†çš„å›¾åƒå°ºå¯¸ï¼Œè¯·åœ¨è¿”å›ç»“æœä¸­åŒ…å«input_widthå’Œinput_heightå­—æ®µã€‚å°è£…ç±»å‹å¿…é¡»æ˜¯BGAã€DIPã€QFNã€QFPã€SODã€SOT23ã€SOT223ä¸­çš„ä¸€ç§ã€‚';
					const result = await callCustomAPI(currentImages, prompt);
					
					// è§£æç‰¹æ®ŠAPIå“åº”
					try {
						// é¦–å…ˆå°è¯•ç›´æ¥è§£æä¸ºJSON
						const parsedResult = JSON.parse(result);
						if (parsedResult.pdf_position_list && Array.isArray(parsedResult.pdf_position_list)) {
							detectionResults = parsedResult;
						} else {
							// å¦‚æœä¸æ˜¯é¢„æœŸæ ¼å¼ï¼Œå°è¯•ä»å…¶ä»–å­—æ®µæå–
							let cleanContent = result;
							// æ›´å¼ºå¥çš„JSONæ¸…ç†é€»è¾‘
							cleanContent = cleanContent.replace(/^```json\s*\n?/i, '');
							cleanContent = cleanContent.replace(/\n?```\s*$/i, '');
							cleanContent = cleanContent.replace(/^```\s*\n?/i, '');
							cleanContent = cleanContent.trim();
							const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
							if (jsonMatch) {
								cleanContent = jsonMatch[0];
							}
							detectionResults = JSON.parse(cleanContent);
						}
					} catch (parseError) {
						console.error('è§£æç‰¹æ®ŠAPIå“åº”å¤±è´¥:', parseError);
						// å¦‚æœJSONè§£æå¤±è´¥ï¼Œå°è¯•æå–JSONä»£ç å—
						let cleanContent = result;
						// æ›´å¼ºå¥çš„JSONæ¸…ç†é€»è¾‘
						cleanContent = cleanContent.replace(/^```json\s*\n?/i, '');
						cleanContent = cleanContent.replace(/\n?```\s*$/i, '');
						cleanContent = cleanContent.replace(/^```\s*\n?/i, '');
						cleanContent = cleanContent.trim();
						const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
						if (jsonMatch) {
							cleanContent = jsonMatch[0];
						}
						detectionResults = JSON.parse(cleanContent);
					}
				} else {
					// é€šä¹‰åƒé—®APIè°ƒç”¨
					// æ„å»ºåŒ…å«æ‰€æœ‰å›¾åƒçš„è¯·æ±‚
					const imageContents = currentImages.map(img => ({
						type: "image_url",
						image_url: { url: img.src }
					}));
					
					const data = {
					model: selectedModel,
					temperature: 0,
					vl_high_resolution_images: true,
					messages: [
							{
								role: 'system',
								content: [{ type: 'text', text: 'You are a professional IC package detection expert.' }]
							},
							{
								role: 'user',
								content: [
									...imageContents,
									{
										type: 'text',
										text: `è¯·åˆ†æè¿™äº›å›¾ç‰‡ï¼Œæœç´¢èŠ¯ç‰‡å°è£…çš„åæ ‡ä½ç½®ã€‚ä»¥JSONæ ¼å¼è¾“å‡ºæ‰€æœ‰çš„èŠ¯ç‰‡å°è£…bboxçš„åæ ‡ï¼Œä¸è¦æ£€æµ‹èŠ¯ç‰‡ç¬¦å·ï¼Œä¸è¦è¾“å‡ºjsonä»£ç æ®µã€‚å¯¹äºæ¯ä¸ªæ£€æµ‹åˆ°çš„å°è£…ï¼Œè¯·è¿”å›ä»¥ä¸‹JSONæ ¼å¼ï¼š\n\n{
  "input_width": æ¨¡å‹å¤„ç†æ—¶çš„å›¾åƒå®½åº¦,
  "input_height": æ¨¡å‹å¤„ç†æ—¶çš„å›¾åƒé«˜åº¦,
  "pdf_position_list": [
    {
      "page_num": é¡µç (ä»1å¼€å§‹),
      "package_type": "å°è£…ç±»å‹(BGA/DIP/QFN/QFP/SOD/SOT23/SOT223)",
      "confidence": ç½®ä¿¡åº¦(0-1),
      "package_rect": {
        "x": xåæ ‡,
        "y": yåæ ‡,
        "width": å®½åº¦,
        "height": é«˜åº¦
      }
    }
  ]
}\n\næ³¨æ„ï¼šåæ ‡åº”è¯¥åŸºäºæ¨¡å‹å®é™…å¤„ç†çš„å›¾åƒå°ºå¯¸ï¼Œè¯·åœ¨è¿”å›ç»“æœä¸­åŒ…å«input_widthå’Œinput_heightå­—æ®µã€‚å°è£…ç±»å‹å¿…é¡»æ˜¯BGAã€DIPã€QFNã€QFPã€SODã€SOT23ã€SOT223ä¸­çš„ä¸€ç§ã€‚
`
									}
								]
							}
						]
					};
					
					const response = await callAPI(data);
					
					if (!response.ok) {
						throw new Error('APIè¯·æ±‚å¤±è´¥');
					}
					
					const result = await response.json();
					let content;
					
					// å¤„ç†ä¸åŒçš„å“åº”æ ¼å¼
					if (selectedProvider === 'zhipu' && result.choices && result.choices[0]) {
						// æ™ºè°±AIå“åº”æ ¼å¼
						content = result.choices[0].message.content;
					} else if (selectedProvider === 'qwen' && result.choices && result.choices[0]) {
						// é€šä¹‰åƒé—®å…¼å®¹æ¨¡å¼å“åº”æ ¼å¼
						content = result.choices[0].message.content;
					} else if (Array.isArray(result) && result[0] && result[0].message) {
						// å¤„ç†æ•°ç»„æ ¼å¼çš„å“åº”
						content = result[0].message.content;
					} else if (result.choices && result.choices[0]) {
						// å¤„ç†æ ‡å‡†æ ¼å¼çš„å“åº”
						content = result.choices[0].message.content;
					} else if (result.pdf_position_list) {
						// å¤„ç†ç›´æ¥è¿”å›æ£€æµ‹ç»“æœçš„æ ¼å¼
						detectionResults = result;
						content = null; // è·³è¿‡contentè§£æ
					} else {
						throw new Error('æ— æ³•è§£æAPIå“åº”æ ¼å¼');
					}
					
					// è§£ææ£€æµ‹ç»“æœ
					try {
						if (content !== null) {
							// æ›´å¼ºå¥çš„JSONæ¸…ç†é€»è¾‘
							let cleanContent = content;
							
							// æ™ºè°±AIç‰¹æ®Šæ ‡è®°å¤„ç†
							if (selectedProvider === 'zhipu') {
								// æå–<|begin_of_box|>å’Œ<|end_of_box|>ä¹‹é—´çš„å†…å®¹
								const boxMatch = cleanContent.match(/<\|begin_of_box\|>([\s\S]*?)<\|end_of_box\|>/);
								if (boxMatch) {
									cleanContent = boxMatch[1].trim();
									console.log('æ™ºè°±AIæå–çš„JSONå†…å®¹:', cleanContent);
								}
							}
							
							// ç§»é™¤å¯èƒ½çš„ä»£ç å—æ ‡è®°
							cleanContent = cleanContent.replace(/^```json\s*\n?/i, '');
							cleanContent = cleanContent.replace(/\n?```\s*$/i, '');
							cleanContent = cleanContent.replace(/^```\s*\n?/i, '');
							
							// ç§»é™¤å¯èƒ½çš„å‰åç©ºç™½å­—ç¬¦
							cleanContent = cleanContent.trim();
							
							// å¦‚æœå†…å®¹ä»¥{å¼€å¤´ä½†å‰é¢æœ‰å…¶ä»–å­—ç¬¦ï¼Œå°è¯•æå–JSONéƒ¨åˆ†
							const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
							if (jsonMatch) {
								cleanContent = jsonMatch[0];
							}
							
							const parsedContent = JSON.parse(cleanContent);
							
							// å¤„ç†å¯èƒ½çš„æ•°ç»„æ ¼å¼å“åº”
							if (Array.isArray(parsedContent) && parsedContent.length > 0) {
								detectionResults = parsedContent[0];
							} else {
								detectionResults = parsedContent;
							}
						}
						// å¦‚æœcontentä¸ºnullï¼Œè¯´æ˜å·²ç»ç›´æ¥è·å¾—äº†detectionResults
					} catch (parseError) {
						console.error('è§£ææ£€æµ‹ç»“æœå¤±è´¥:', parseError);
						throw new Error('è§£ææ£€æµ‹ç»“æœå¤±è´¥: ' + parseError.message);
					}
				}
						
						console.log('è§£æçš„æ£€æµ‹ç»“æœ:', detectionResults);
						
						// åœæ­¢è®¡æ—¶
						stopTiming();
						
						// ç»˜åˆ¶æ£€æµ‹æ¡†
						drawDetectionBoxes();
						
						// éªŒè¯æ£€æµ‹ç»“æœæ•°æ®ç»“æ„
						if (!detectionResults || !detectionResults.pdf_position_list || !Array.isArray(detectionResults.pdf_position_list)) {
							throw new Error('æ£€æµ‹ç»“æœæ•°æ®æ ¼å¼ä¸æ­£ç¡®');
						}
						
						// è‡ªåŠ¨è®¾ç½®ç¬¬ä¸€ä¸ªæ£€æµ‹åˆ°çš„å°è£…ç±»å‹åˆ°ä¸‹æ‹‰æ¡†ï¼ˆä½†ä¸è‡ªåŠ¨æ˜¾ç¤ºå‚æ•°ï¼‰
					if (detectionResults.pdf_position_list.length > 0) {
						let firstPackageType = detectionResults.pdf_position_list[0].package_type;
						// åŒ…å«BGAçš„å°è£…ç±»å‹è‡ªåŠ¨å½’ç±»åˆ°BGA
					if (firstPackageType && firstPackageType.includes('BGA')) {
						firstPackageType = 'BGA';
					}
					// åŒ…å«DIPçš„å°è£…ç±»å‹è‡ªåŠ¨å½’ç±»åˆ°DIP
					if (firstPackageType && firstPackageType.includes('DIP')) {
						firstPackageType = 'DIP';
					}
						if (firstPackageType && packageTypeSelect.value !== firstPackageType) {
							packageTypeSelect.value = firstPackageType;
							// ä¸è°ƒç”¨onPackageTypeChange()ï¼Œé¿å…è‡ªåŠ¨æ˜¾ç¤ºå‚æ•°
						}
						eda.sys_ToastMessage.showMessage(`å°è£…ç±»å‹ä¸º${firstPackageType}`, 3);
							
							// è‡ªåŠ¨è·³è½¬åˆ°ç¬¬ä¸€ä¸ªæ£€æµ‹æ¡†æ‰€åœ¨çš„é¡µé¢
							const firstDetection = detectionResults.pdf_position_list[0];
							const firstDetectionPage = firstDetection.page_num;
							const targetImageIndex = firstDetectionPage - 1;
							
							if (targetImageIndex >= 0 && targetImageIndex < currentImages.length && targetImageIndex !== currentImageIndex) {
									// ä¿å­˜å½“å‰å›¾ç‰‡çš„æ¡†é€‰çŠ¶æ€
									saveCurrentImageSelection();
									// è·³è½¬åˆ°ç›®æ ‡é¡µé¢
								currentImageIndex = targetImageIndex;
								displayCurrentImage();
								eda.sys_ToastMessage.showMessage(`å·²è‡ªåŠ¨è·³è½¬åˆ°ç¬¬ ${firstDetectionPage} é¡µ`, 1);
							}
							
							// æ£€æŸ¥æ£€æµ‹åˆ°çš„å°è£…åœ¨å“ªäº›é¡µé¢
							const detectedPages = [...new Set(detectionResults.pdf_position_list.map(d => d.page_num))].sort((a, b) => a - b);
							const currentPageNum = currentImageIndex + 1;
							
							if (detectedPages.includes(currentPageNum)) {
								eda.sys_ToastMessage.showMessage(`æ£€æµ‹åˆ° ${detectionResults.pdf_position_list.length} ä¸ªå°è£…ï¼Œå½“å‰é¡µé¢æœ‰æ£€æµ‹æ¡†ï¼Œè¯·ç¡®è®¤åç‚¹å‡»æå–å‚æ•°`, 1);
							} else {
								eda.sys_ToastMessage.showMessage(`æ£€æµ‹åˆ° ${detectionResults.pdf_position_list.length} ä¸ªå°è£…åœ¨ç¬¬ ${detectedPages.join('ã€')} é¡µï¼Œè¯·åˆ‡æ¢åˆ°å¯¹åº”é¡µé¢æŸ¥çœ‹æ£€æµ‹æ¡†`, 1);
							}
						} else {
							eda.sys_ToastMessage.showMessage('æœªæ£€æµ‹åˆ°å°è£…', 0);
						}
						
						// æ›´æ–°æŒ‰é’®çŠ¶æ€
						updateButtons();
					} catch (parseError) {
					console.error('è§£ææ£€æµ‹ç»“æœå¤±è´¥:', parseError);
					console.error('åŸå§‹å†…å®¹:', content);
					// åœæ­¢è®¡æ—¶
					stopTiming();
					eda.sys_ToastMessage.showMessage('è§£ææ£€æµ‹ç»“æœå¤±è´¥', 0);
				}
				
			} 
			
			/**
			 * æ¯”è¾ƒä¸¤æ¬¡æå–ç»“æœï¼Œé€‰æ‹©æ›´å¥½çš„ä¸€ä¸ª
			 */
			function chooseBetterResult(firstResult, secondResult) {
				if (!firstResult) return secondResult;
				if (!secondResult) return firstResult;
				
				try {
					// å°è¯•è§£æä¸¤ä¸ªç»“æœ
					const first = parseParametersFromContent(firstResult);
					const second = parseParametersFromContent(secondResult);
					
					// å¦‚æœåªæœ‰ä¸€ä¸ªè§£ææˆåŠŸï¼Œé€‰æ‹©æˆåŠŸçš„
					if (first && !second) return firstResult;
					if (!first && second) return secondResult;
					if (!first && !second) return secondResult; // éƒ½å¤±è´¥æ—¶é€‰æ‹©ç¬¬äºŒä¸ª
					
					// éƒ½æˆåŠŸæ—¶ï¼Œé€‰æ‹©å‚æ•°æ›´å¤šçš„
					const firstCount = first.parameters ? first.parameters.length : 0;
					const secondCount = second.parameters ? second.parameters.length : 0;
					
					console.log(`ç¬¬ä¸€æ¬¡æå–å‚æ•°æ•°é‡: ${firstCount}, ç¬¬äºŒæ¬¡æå–å‚æ•°æ•°é‡: ${secondCount}`);
					
					// å¦‚æœå‚æ•°æ•°é‡ç›¸åŒï¼Œé€‰æ‹©ç¬¬äºŒä¸ªï¼ˆé€šå¸¸æ›´ç¨³å®šï¼‰
					// å¦‚æœç¬¬äºŒä¸ªå‚æ•°æ›´å¤šï¼Œé€‰æ‹©ç¬¬äºŒä¸ª
					// å¦‚æœç¬¬ä¸€ä¸ªå‚æ•°æ˜æ˜¾æ›´å¤šï¼ˆå·®è·>=2ï¼‰ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
					if (secondCount >= firstCount || (firstCount - secondCount < 2)) {
						console.log('é€‰æ‹©ç¬¬äºŒæ¬¡æå–ç»“æœ');
						return secondResult;
					} else {
						console.log('é€‰æ‹©ç¬¬ä¸€æ¬¡æå–ç»“æœï¼ˆå‚æ•°æ›´å¤šï¼‰');
						return firstResult;
					}
				} catch (error) {
					console.error('æ¯”è¾ƒç»“æœæ—¶å‡ºé”™:', error);
					// å‡ºé”™æ—¶é»˜è®¤é€‰æ‹©ç¬¬äºŒä¸ª
					return secondResult;
				}
			}
			
			/**
			 * ä»å†…å®¹ä¸­è§£æå‚æ•°ï¼ˆç”¨äºæ¯”è¾ƒï¼‰
			 */
			function parseParametersFromContent(content) {
				try {
					// æŸ¥æ‰¾JSONä»£ç å—
					const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/g;
					let match;
					
					while ((match = jsonBlockRegex.exec(content)) !== null) {
						try {
							const jsonContent = match[1].trim();
							const parsed = JSON.parse(jsonContent);
							if (parsed.parameters && Array.isArray(parsed.parameters)) {
								return parsed;
							}
						} catch (e) {
							continue;
						}
					}
					
					// å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»£ç å—ï¼Œå°è¯•ç›´æ¥è§£æ
					try {
						const parsed = JSON.parse(content);
						if (parsed.parameters && Array.isArray(parsed.parameters)) {
							return parsed;
						}
					} catch (e) {
						// å¿½ç•¥è§£æé”™è¯¯
					}
					
					return null;
				} catch (error) {
					return null;
				}
			}
			
			/**
			 * æå–å‚æ•° - ç¬¬äºŒæ­¥ï¼šæå–å°è£…å‚æ•°
			 */
			async function extractParams() {
				apiKey = apiKeyInput.value.trim();
			selectedModel = modelSelect.value;
			selectedProvider = providerSelect.value;
			apiUrl = apiUrlInput.value.trim();
			customApiUrl = apiUrlInput.value.trim();
				
				// è‡ªå®šä¹‰APIä¸éœ€è¦APIå¯†é’¥
				if (!isSpecialApiFormat(selectedProvider, apiUrl) && !apiKey) {
					eda.sys_ToastMessage.showMessage('è¯·è¾“å…¥APIå¯†é’¥', 0);
					return;
				}
				
				// ç‰¹æ®ŠAPIä½¿ç”¨é»˜è®¤åœ°å€
				if (isSpecialApiFormat(selectedProvider, apiUrl)) {
				customApiUrl = apiUrl;
				}
				
				// æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡æœ‰æ¡†é€‰ï¼ˆæ‰‹åŠ¨æ¡†é€‰æˆ–æœç´¢ä½ç½®çš„è‡ªåŠ¨æ¡†é€‰ï¼‰
				const imagesWithSelections = [];
				
				for (let i = 0; i < currentImages.length; i++) {
					const imageKey = `image_${i}`;
					const selections = imageSelections[imageKey];
					
					if (selections && selections.length > 0) {
						imagesWithSelections.push({
							index: i,
							image: currentImages[i],
							selections: selections
						});
					}
				}
				
				if (imagesWithSelections.length === 0) {
					eda.sys_ToastMessage.showMessage('è¯·å…ˆè¿›è¡Œæ‰‹åŠ¨æ¡†é€‰æˆ–æœç´¢ä½ç½®', 0);
					return;
				}
				
				try {
	eda.sys_ToastMessage.showMessage(`æ­£åœ¨æå– ${imagesWithSelections.length} å¼ å›¾ç‰‡çš„å°è£…å‚æ•°...`, 3);
	
	// å¼€å§‹è®¡æ—¶
	startTiming();
	
	// è·å–å½“å‰é€‰æ‹©çš„å°è£…ç±»å‹
	const selectedPackageType = packageTypeSelect.value;
	let paramPrompt = '';
	let extractionCount = 2; // é»˜è®¤æå–2æ¬¡
				
	if (selectedPackageType) {
		// å¦‚æœå·²ç»é€‰æ‹©äº†å°è£…ç±»å‹ï¼Œåªæå–ä¸€æ¬¡
		extractionCount = 1;
		// æ ¹æ®é€‰æ‹©çš„å°è£…ç±»å‹ç”Ÿæˆæç¤ºè¯
		const typeParams = packageParams[selectedPackageType];
		if (typeParams) {
			const paramList = typeParams.map(p => `${p.name}(${p.key})`).join('ã€');
			paramPrompt = `ä»èŠ¯ç‰‡å°è£…æ‰‹å†Œå›¾ä¸­æå–${selectedPackageType}å°è£…çš„å‚æ•°ï¼ŒåŒ…æ‹¬ï¼š${paramList}ã€‚è¯·ä»”ç»†æµ‹é‡å›¾ä¸­çš„å°ºå¯¸æ ‡æ³¨ï¼Œä»¥æ¯«ç±³ä¸ºå•ä½ã€‚`;
		}
	} else {
		// å¦‚æœæ²¡æœ‰é€‰æ‹©ç±»å‹ï¼Œè®©AIè‡ªåŠ¨è¯†åˆ«ï¼Œæ‰§è¡Œä¸¤æ¬¡æå–
		paramPrompt = 'ä»èŠ¯ç‰‡å°è£…æ‰‹å†Œå›¾ä¸­è¯†åˆ«å°è£…ç±»å‹ï¼ˆBGAã€DIPã€QFNã€QFPã€SODã€SOT23ã€SOT223ä¸­çš„ä¸€ç§ï¼‰ï¼Œå¹¶æå–ç›¸åº”çš„å°è£…å‚æ•°ã€‚è¯·ä»”ç»†æµ‹é‡å›¾ä¸­çš„å°ºå¯¸æ ‡æ³¨ï¼Œä»¥æ¯«ç±³ä¸ºå•ä½ã€‚';
	}
	
	let content;
	let firstResult = null;
	let secondResult = null;
	let detectedPackageType = null; // å­˜å‚¨ç¬¬ä¸€æ¬¡æå–è¯†åˆ«åˆ°çš„å°è£…ç±»å‹
	
	// æ ¹æ®æ˜¯å¦é€‰æ‹©å°è£…ç±»å‹å†³å®šæå–æ¬¡æ•°
	for (let attempt = 1; attempt <= extractionCount; attempt++) {
		eda.sys_ToastMessage.showMessage(`æ­£åœ¨è¿›è¡Œç¬¬ ${attempt} æ¬¡æå–...`, 3);
		
		// åœ¨ä¸¤æ¬¡æå–ä¹‹é—´æ·»åŠ 2ç§’é—´éš”ï¼ˆä»…åœ¨éœ€è¦ä¸¤æ¬¡æå–æ—¶ï¼‰
		if (attempt === 2 && extractionCount === 2) {
			console.log('ç­‰å¾…2ç§’åè¿›è¡Œç¬¬äºŒæ¬¡æå–...');
			await new Promise(resolve => setTimeout(resolve, 2000));
		}
		
		// ä¸ºç¬¬äºŒæ¬¡æå–ç”Ÿæˆæ›´ç²¾ç¡®çš„promptï¼ˆä»…åœ¨éœ€è¦ä¸¤æ¬¡æå–æ—¶ï¼‰
		let currentPrompt = paramPrompt;
		if (attempt === 2 && detectedPackageType && extractionCount === 2) {
			// ç¬¬äºŒæ¬¡æå–ä½¿ç”¨ç¬¬ä¸€æ¬¡è¯†åˆ«åˆ°çš„å°è£…ç±»å‹
			const typeParams = packageParams[detectedPackageType];
			if (typeParams) {
				const paramList = typeParams.map(p => `${p.name}(${p.key})`).join('ã€');
				currentPrompt = `ä»èŠ¯ç‰‡å°è£…æ‰‹å†Œå›¾ä¸­æå–${detectedPackageType}å°è£…çš„å‚æ•°ï¼ŒåŒ…æ‹¬ï¼š${paramList}ã€‚è¯·ä»”ç»†æµ‹é‡å›¾ä¸­çš„å°ºå¯¸æ ‡æ³¨ï¼Œä»¥æ¯«ç±³ä¸ºå•ä½ã€‚`;
				console.log(`ç¬¬äºŒæ¬¡æå–ä½¿ç”¨æ£€æµ‹åˆ°çš„å°è£…ç±»å‹: ${detectedPackageType}`);
			}
		}
	
		if (selectedProvider === 'custom' && apiUrl === 'https://chat.eda.cn/ai-chat-api/complete') {
			// ç‰¹æ®ŠAPIè°ƒç”¨
			const images = imagesWithSelections.map(imageData => imageData.image);
			const fullPrompt = `${currentPrompt}è¯·ä»¥JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦è¾“å‡ºjsonä»£ç æ®µï¼ŒJSONæ ¼å¼å¦‚ä¸‹ï¼š\n\`\`\`json\n{\n  "package_type": "QFN",\n  "parameters": [\n    {"name": "æœ¬ä½“é•¿åº¦", "key": "BL", "value": "5.0", "unit": "mm"},\n    {"name": "æœ¬ä½“å®½åº¦", "key": "BW", "value": "5.0", "unit": "mm"}\n  ]\n}\n\`\`\``;
			content = await callCustomAPI(images, fullPrompt);
		} else {
			// é€šä¹‰åƒé—®APIè°ƒç”¨
			// æ„å»ºåŒ…å«æ‰€æœ‰æœ‰æ¡†é€‰å›¾ç‰‡çš„è¯·æ±‚
			const imageContents = [];
			let totalSelections = 0;
			
			for (const imageData of imagesWithSelections) {
				console.log(`æ·»åŠ å›¾ç‰‡ ${imageData.index + 1}ï¼Œæ¡†é€‰æ•°é‡: ${imageData.selections.length}`);
				imageContents.push({
					type: "image_url",
					image_url: { url: imageData.image.src }
				});
				totalSelections += imageData.selections.length;
			}
			
			// æ·»åŠ æ–‡æœ¬æç¤º
			imageContents.push({
				type: 'text',
				text: `${currentPrompt}è¯·ä»¥JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦è¾“å‡ºjsonä»£ç æ®µï¼ŒJSONæ ¼å¼å¦‚ä¸‹ï¼š\n\`\`\`json\n{\n  "package_type": "QFN",\n  "parameters": [\n    {"name": "æœ¬ä½“é•¿åº¦", "key": "BL", "value": "5.0", "unit": "mm"},\n    {"name": "æœ¬ä½“å®½åº¦", "key": "BW", "value": "5.0", "unit": "mm"}\n  ]\n}\n\`\`\``
			});
			
			const data = {
				model: selectedModel,
				temperature: 0,
				vl_high_resolution_images: true,
				messages: [
					{
						role: 'system',
						content: [{ type: 'text', text: 'You are a professional IC package analysis expert specialized in extracting package parameters from technical documentation.' }]
					},
					{
						role: 'user',
						content: imageContents
					}
				]
			};
			
			const response = await callAPI(data);
			
			if (!response.ok) {
				throw new Error('APIè¯·æ±‚å¤±è´¥');
			}
			
			let result;
			
			if (isSpecialApiFormat(selectedProvider, apiUrl)) {
				// ç‰¹æ®ŠAPIå“åº”å¤„ç†
				const responseText = await response.text();
				console.log('ç‰¹æ®ŠAPIåŸå§‹å“åº”:', responseText);
				
				// é¦–å…ˆå°è¯•ç›´æ¥è§£æä¸ºJSON
				try {
					result = JSON.parse(responseText);
					console.log('ç‰¹æ®ŠAPIå“åº”è§£ææˆåŠŸ:', result);
					
					// å¦‚æœç›´æ¥è§£ææˆåŠŸä¸”åŒ…å«parametersæ•°ç»„ï¼Œç›´æ¥ä½¿ç”¨
					if (result.parameters && Array.isArray(result.parameters)) {
						console.log('ç‰¹æ®ŠAPIç›´æ¥è¿”å›äº†parametersæ•°ç»„');
						content = JSON.stringify(result);
					} else {
						// å¦åˆ™æŒ‰ç…§åŸæœ‰é€»è¾‘å¤„ç†
						if (result.context && result.context.chat && result.context.chat.input_text) {
							content = result.context.chat.input_text;
						} else if (result.data && result.data.content) {
							content = result.data.content;
						} else if (result.content) {
							content = result.content;
						} else if (result.response) {
							content = result.response;
						} else {
							// å¦‚æœéƒ½æ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•å°†æ•´ä¸ªresultä½œä¸ºå†…å®¹
							content = JSON.stringify(result);
							console.log('ä½¿ç”¨æ•´ä¸ªresultä½œä¸ºå†…å®¹:', content);
						}
					}
				} catch (parseError) {
					// å¦‚æœJSONè§£æå¤±è´¥ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ–‡æœ¬
					console.log('ç‰¹æ®ŠAPIå“åº”ä¸æ˜¯JSONæ ¼å¼ï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬:', responseText);
					content = responseText;
				}
			} else {
				// é€šä¹‰åƒé—®ã€æ™ºè°±AIå’Œè‡ªå®šä¹‰APIå“åº”å¤„ç†
				result = await response.json();
				console.log('APIå“åº”JSONè§£æç»“æœ:', result);
				
				// å¤„ç†ä¸åŒçš„å“åº”æ ¼å¼
				if (selectedProvider === 'zhipu' && result.choices && result.choices[0]) {
					// æ™ºè°±AIå“åº”æ ¼å¼
					content = result.choices[0].message.content;
					console.log('æ™ºè°±AIæå–çš„content:', content);
					console.log('æ™ºè°±AI contentç±»å‹:', typeof content);
				} else if (Array.isArray(result) && result[0] && result[0].message) {
					// å¤„ç†æ•°ç»„æ ¼å¼çš„å“åº”
					content = result[0].message.content;
					console.log('æ•°ç»„æ ¼å¼æå–çš„content:', content);
				} else if (result.choices && result.choices[0]) {
					// å¤„ç†æ ‡å‡†æ ¼å¼çš„å“åº”
					content = result.choices[0].message.content;
					console.log('æ ‡å‡†æ ¼å¼æå–çš„content:', content);
				} else {
					console.error('æ— æ³•è¯†åˆ«çš„APIå“åº”æ ¼å¼:', result);
					throw new Error('æ— æ³•è§£æAPIå“åº”æ ¼å¼');
				}
				
				// ç«‹å³éªŒè¯content
				console.log('å“åº”å¤„ç†åçš„content:', content, 'ç±»å‹:', typeof content);
			}
		}
		
		// éªŒè¯contentæ˜¯å¦æœ‰æ•ˆ
		if (!content || typeof content !== 'string') {
			console.error('contentä¸ºç©ºæˆ–ä¸æ˜¯å­—ç¬¦ä¸²:', content);
			throw new Error('APIè¿”å›çš„å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯');
		}
		
		console.log(`ç¬¬ ${attempt} æ¬¡æå–ç»“æœ:`, content);
		
		// å­˜å‚¨æå–ç»“æœ
		if (attempt === 1) {
			firstResult = content;
			// ä»ç¬¬ä¸€æ¬¡æå–ç»“æœä¸­è·å–å°è£…ç±»å‹ï¼ˆä»…åœ¨éœ€è¦ä¸¤æ¬¡æå–æ—¶ï¼‰
			if (extractionCount === 2) {
				try {
					const parsedResult = parseParametersFromContent(content);
					if (parsedResult && parsedResult.package_type) {
						detectedPackageType = parsedResult.package_type;
						console.log(`ç¬¬ä¸€æ¬¡æå–è¯†åˆ«åˆ°å°è£…ç±»å‹: ${detectedPackageType}`);
					}
				} catch (error) {
					console.warn('è§£æç¬¬ä¸€æ¬¡æå–ç»“æœæ—¶å‡ºé”™:', error);
				}
				console.log('ç¬¬ä¸€æ¬¡æå–å®Œæˆï¼Œå‡†å¤‡è¿›è¡Œç¬¬äºŒæ¬¡æå–...');
			}
		} else {
			secondResult = content;
		}
	}
	
	// æ ¹æ®æå–æ¬¡æ•°é€‰æ‹©æœ€ä½³ç»“æœ
	let bestResult;
	if (extractionCount === 1) {
		// åªæå–ä¸€æ¬¡ï¼Œç›´æ¥ä½¿ç”¨ç»“æœ
		bestResult = firstResult;
		console.log('å·²é€‰æ‹©å°è£…ç±»å‹ï¼Œä½¿ç”¨å•æ¬¡æå–ç»“æœ:', bestResult);
	} else {
		// æ¯”è¾ƒä¸¤æ¬¡ç»“æœå¹¶é€‰æ‹©æ›´å¥½çš„
		bestResult = chooseBetterResult(firstResult, secondResult);
		console.log('é€‰æ‹©çš„æœ€ä½³ç»“æœ:', bestResult);
	}
	
	// ä½¿ç”¨æœ€ä½³ç»“æœè¿›è¡Œå‚æ•°è§£æ
	parseAndAddParams(bestResult);
	
	// åœæ­¢è®¡æ—¶
	stopTiming();
	
	// æ ¹æ®æå–æ¬¡æ•°æ˜¾ç¤ºä¸åŒçš„æˆåŠŸæ¶ˆæ¯
	const successMessage = extractionCount === 1 
		? `æˆåŠŸæå– ${imagesWithSelections.length} å¼ å›¾ç‰‡çš„å°è£…å‚æ•°ï¼ˆå·²é€‰æ‹©å°è£…ç±»å‹ï¼‰`
		: `æˆåŠŸæå– ${imagesWithSelections.length} å¼ å›¾ç‰‡çš„å°è£…å‚æ•°ï¼ˆæ™ºèƒ½é€‰æ‹©æœ€ä½³ç»“æœï¼‰`;
	eda.sys_ToastMessage.showMessage(successMessage, 1);
	
} catch (error) {
	console.error('æå–å‚æ•°å¤±è´¥:', error);
	// åœæ­¢è®¡æ—¶
	stopTiming();
	eda.sys_ToastMessage.showMessage('æå–å‚æ•°å¤±è´¥: ' + error.message, 0);
}
}
			
			// æ‰‹åŠ¨é€‰æ‹©çŠ¶æ€å˜é‡
			let manualSelectionMode = false;
			let firstPoint = null;
			let tempSelectionBox = null;
			
			/**
			 * åˆ‡æ¢æ‰‹åŠ¨æ¡†é€‰æ¨¡å¼
			 */
			function toggleManualSelection() {
				if (manualSelectionMode) {
					stopManualSelection();
					manualSelectButton.textContent = 'æ‰‹åŠ¨æ¡†é€‰';
				} else {
					startManualSelection();
					manualSelectButton.textContent = 'åœæ­¢æ¡†é€‰';
				}
			}
			
			/**
			 * å¼€å§‹æ‰‹åŠ¨é€‰æ‹©æ¨¡å¼
			 */
			function startManualSelection() {
				manualSelectionMode = true;
				firstPoint = null;
				if (imageDisplay) {
					imageDisplay.classList.add('selecting');
				}
				// ç¡®ä¿selectionOverlayå¯ä»¥æ¥æ”¶é¼ æ ‡äº‹ä»¶
				if (selectionOverlay) {
					selectionOverlay.style.pointerEvents = 'all';
				}
				eda.sys_ToastMessage.showMessage('è¯·ç‚¹å‡»å›¾ç‰‡é€‰æ‹©èµ·ç‚¹', 2);
			}
			
			/**
			 * åœæ­¢æ‰‹åŠ¨é€‰æ‹©æ¨¡å¼
			 */
			function stopManualSelection() {
				manualSelectionMode = false;
				firstPoint = null;
				if (imageDisplay) {
					imageDisplay.classList.remove('selecting');
				}
				
				// é‡ç½®selectionOverlayçš„pointer-events
				if (selectionOverlay) {
					selectionOverlay.style.pointerEvents = 'none';
				}
				
				// æ¸…é™¤ä¸´æ—¶é€‰æ‹©æ¡†
				if (tempSelectionBox) {
					tempSelectionBox.remove();
					tempSelectionBox = null;
				}
			}
			
			// å­˜å‚¨äº‹ä»¶ç›‘å¬å™¨å¼•ç”¨
			let manualSelectionHandlers = {
				click: null
			};
			
			/**
			 * åˆå§‹åŒ–æ‰‹åŠ¨é€‰æ‹©åŠŸèƒ½
			 */
			function initManualSelection() {
				if (!selectionOverlay) return;
				
				console.log('åˆå§‹åŒ–æ‰‹åŠ¨é€‰æ‹©åŠŸèƒ½');
				
				// ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
				if (manualSelectionHandlers.click) {
					selectionOverlay.removeEventListener('click', manualSelectionHandlers.click);
				}
				
				// ç¡®ä¿overlayè¦†ç›–æ•´ä¸ªå›¾åƒåŒºåŸŸ
				selectionOverlay.style.position = 'absolute';
				selectionOverlay.style.top = '0';
				selectionOverlay.style.left = '0';
				selectionOverlay.style.width = '100%';
				selectionOverlay.style.height = '100%';
				selectionOverlay.style.zIndex = '10';
				
				// åˆ›å»ºç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
				manualSelectionHandlers.click = (e) => {
					if (!manualSelectionMode) return;
					
					const rect = selectionOverlay.getBoundingClientRect();
					const clickPoint = {
						x: e.clientX - rect.left,
						y: e.clientY - rect.top
					};
					
					if (!firstPoint) {
						// ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šè®¾ç½®èµ·ç‚¹
						firstPoint = clickPoint;
						console.log('è®¾ç½®èµ·ç‚¹:', firstPoint);
						
						// åˆ›å»ºèµ·ç‚¹æ ‡è®°
						const startMarker = document.createElement('div');
						startMarker.className = 'start-marker';
						startMarker.style.position = 'absolute';
						startMarker.style.left = (firstPoint.x - 3) + 'px';
						startMarker.style.top = (firstPoint.y - 3) + 'px';
						startMarker.style.width = '6px';
						startMarker.style.height = '6px';
						startMarker.style.backgroundColor = '#ff0000';
						startMarker.style.borderRadius = '50%';
						startMarker.style.zIndex = '15';
						selectionOverlay.appendChild(startMarker);
						
						eda.sys_ToastMessage.showMessage('èµ·ç‚¹å·²è®¾ç½®ï¼Œè¯·ç‚¹å‡»ç»ˆç‚¹', 2);
					} else {
						// ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼šè®¾ç½®ç»ˆç‚¹å¹¶åˆ›å»ºé€‰æ‹©æ¡†
						const secondPoint = clickPoint;
						console.log('è®¾ç½®ç»ˆç‚¹:', secondPoint);
						
						// è®¡ç®—é€‰æ‹©æ¡†çš„ä½ç½®å’Œå°ºå¯¸
						const left = Math.min(firstPoint.x, secondPoint.x);
						const top = Math.min(firstPoint.y, secondPoint.y);
						const width = Math.abs(secondPoint.x - firstPoint.x);
						const height = Math.abs(secondPoint.y - firstPoint.y);
						
						// åˆ›å»ºé€‰æ‹©æ¡†
						const selectionBox = document.createElement('div');
						selectionBox.className = 'selection-box';
						selectionBox.style.position = 'absolute';
						selectionBox.style.left = left + 'px';
						selectionBox.style.top = top + 'px';
						selectionBox.style.width = width + 'px';
						selectionBox.style.height = height + 'px';
						selectionBox.style.border = '2px solid #007bff';
						selectionBox.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
						selectionBox.style.zIndex = '12';
						selectionOverlay.appendChild(selectionBox);
						
						// æ›´æ–°åæ ‡æ˜¾ç¤º
						updateCoordinateDisplay(left, top, width, height);
						
						// ä¿å­˜æ‰‹åŠ¨é€‰æ‹©æ¡†åˆ°imageSelections
						const imageKey = `image_${currentImageIndex}`;
						if (!imageSelections[imageKey]) {
							imageSelections[imageKey] = [];
						}
						imageSelections[imageKey].push({
							type: 'manual',
							left: left + 'px',
							top: top + 'px',
							width: width + 'px',
							height: height + 'px',
							border: '2px solid #007bff',
							backgroundColor: 'rgba(0, 123, 255, 0.1)'
						});
						
						console.log('æ‰‹åŠ¨é€‰æ‹©å®Œæˆ:', {
							page: currentImageIndex + 1,
							selection: { left, top, width, height }
						});
						console.log(`ä¿å­˜æ‰‹åŠ¨æ¡†é€‰åˆ°å›¾ç‰‡ ${currentImageIndex + 1}:`, imageSelections[imageKey]);
						
						// æ›´æ–°æŒ‰é’®çŠ¶æ€
						updateButtons();
						
						// åœæ­¢é€‰æ‹©æ¨¡å¼
						stopManualSelection();
						manualSelectButton.textContent = 'æ‰‹åŠ¨æ¡†é€‰';
						
						eda.sys_ToastMessage.showMessage('é€‰æ‹©æ¡†å·²åˆ›å»º', 1);
					}
					
					e.preventDefault();
					e.stopPropagation();
				};
				
				// æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
				selectionOverlay.addEventListener('click', manualSelectionHandlers.click);
			}
			
			/**
			 * ç»˜åˆ¶æ£€æµ‹æ¡†
			 */
			function drawDetectionBoxes() {
				console.log('å¼€å§‹ç»˜åˆ¶æ£€æµ‹æ¡†ï¼ŒdetectionResults:', detectionResults);
				
				if (!detectionResults || !detectionResults.pdf_position_list) {
					console.log('æ²¡æœ‰æ£€æµ‹ç»“æœï¼Œè·³è¿‡ç»˜åˆ¶');
					return;
				}
				
				// æ¸…é™¤ç°æœ‰æ£€æµ‹æ¡†
				const existingBoxes = selectionOverlay.querySelectorAll('.detection-box');
				console.log('æ¸…é™¤ç°æœ‰æ£€æµ‹æ¡†æ•°é‡:', existingBoxes.length);
				existingBoxes.forEach(box => box.remove());
				
				// è·å–å½“å‰å›¾åƒ
				const currentImage = imageDisplay.querySelector('img');
				if (!currentImage) {
					console.log('æ²¡æœ‰æ‰¾åˆ°å½“å‰å›¾åƒ');
					return;
				}
				
				console.log('å½“å‰å›¾åƒç´¢å¼•:', currentImageIndex);
				
				// ç­‰å¾…å›¾åƒåŠ è½½å®Œæˆåç»˜åˆ¶
				function drawBoxes() {
					const imageRect = currentImage.getBoundingClientRect();
					const overlayRect = selectionOverlay.getBoundingClientRect();
					
					console.log('å›¾åƒå°ºå¯¸:', {
						imageRect: imageRect,
						overlayRect: overlayRect,
						naturalWidth: currentImage.naturalWidth,
						naturalHeight: currentImage.naturalHeight
					});
					
					// ä¿®æ­£ï¼šè®¡ç®—å›¾ç‰‡ç›¸å¯¹äºoverlayçš„å®é™…åç§»
					const offsetX = imageRect.left - overlayRect.left;
					const offsetY = imageRect.top - overlayRect.top;
					
					// è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
					const scaleX = imageRect.width / currentImage.naturalWidth;
					const scaleY = imageRect.height / currentImage.naturalHeight;
					
					console.log('ç¼©æ”¾å‚æ•°:', { offsetX, offsetY, scaleX, scaleY });
					
					// ç»˜åˆ¶å½“å‰é¡µé¢çš„æ£€æµ‹æ¡†
			const currentPageNum = currentImageIndex + 1;
			console.log('å½“å‰é¡µç :', currentPageNum);
			
			// è·å–æ¨¡å‹è¾“å…¥å°ºå¯¸ä¿¡æ¯ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
			const modelInputWidth = detectionResults.input_width || currentImage.naturalWidth;
			const modelInputHeight = detectionResults.input_height || currentImage.naturalHeight;
			
			console.log('åæ ‡æ˜ å°„å‚æ•°:', {
				modelInputWidth,
				modelInputHeight,
				originalWidth: currentImage.naturalWidth,
				originalHeight: currentImage.naturalHeight,
				needMapping: modelInputWidth !== currentImage.naturalWidth || modelInputHeight !== currentImage.naturalHeight,
				scaleFactorX: currentImage.naturalWidth / modelInputWidth,
				scaleFactorY: currentImage.naturalHeight / modelInputHeight
			});
			
			let drawnBoxes = 0;
			detectionResults.pdf_position_list.forEach((detection, index) => {
				console.log(`æ£€æµ‹ç»“æœ ${index}:`, detection);
				
				if (detection.page_num === currentPageNum) {
					const rect = detection.package_rect;
					
					// åæ ‡æ˜ å°„ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦ä»æ¨¡å‹è¾“å…¥å°ºå¯¸æ˜ å°„åˆ°åŸå›¾å°ºå¯¸
					let mappedX, mappedY, mappedWidth, mappedHeight;
					
					// å¦‚æœæ¨¡å‹è¾“å…¥å°ºå¯¸ä¸åŸå›¾å°ºå¯¸ä¸åŒï¼Œè¯´æ˜éœ€è¦æ˜ å°„
					if (modelInputWidth !== currentImage.naturalWidth || modelInputHeight !== currentImage.naturalHeight) {
						// ä»æ¨¡å‹è¾“å…¥å°ºå¯¸æ˜ å°„åˆ°åŸå›¾å°ºå¯¸
						mappedX = (rect.x / modelInputWidth) * currentImage.naturalWidth;
						mappedY = (rect.y / modelInputHeight) * currentImage.naturalHeight;
						mappedWidth = (rect.width / modelInputWidth) * currentImage.naturalWidth;
						mappedHeight = (rect.height / modelInputHeight) * currentImage.naturalHeight;
					} else {
						// åæ ‡å·²ç»æ˜¯åŸºäºåŸå›¾å°ºå¯¸çš„ï¼Œç›´æ¥ä½¿ç”¨
						mappedX = rect.x;
						mappedY = rect.y;
						mappedWidth = rect.width;
						mappedHeight = rect.height;
					}
					
					const detectionBox = document.createElement('div');
					detectionBox.className = 'detection-box';
					
					// åº”ç”¨æ˜¾ç¤ºç¼©æ”¾
					const left = offsetX + mappedX * scaleX;
					const top = offsetY + mappedY * scaleY;
					const width = mappedWidth * scaleX;
					const height = mappedHeight * scaleY;
					
					// è¾¹ç•Œæ£€æŸ¥ï¼šç¡®ä¿æ£€æµ‹æ¡†ä¸è¶…å‡ºå›¾ç‰‡èŒƒå›´
					const maxLeft = offsetX + imageRect.width;
					const maxTop = offsetY + imageRect.height;
					
					if (left >= offsetX && top >= offsetY && 
						left + width <= maxLeft && top + height <= maxTop) {
						
						detectionBox.style.left = left + 'px';
						detectionBox.style.top = top + 'px';
						detectionBox.style.width = width + 'px';
						detectionBox.style.height = height + 'px';
						
						console.log(`ç»˜åˆ¶æ£€æµ‹æ¡† ${index}:`, {
							original: rect,
							mapped: { mappedX, mappedY, mappedWidth, mappedHeight },
							scaled: { left, top, width, height },
							mappingApplied: modelInputWidth !== currentImage.naturalWidth || modelInputHeight !== currentImage.naturalHeight,
							scaleFactors: {
								x: currentImage.naturalWidth / modelInputWidth,
								y: currentImage.naturalHeight / modelInputHeight
							}
						});
						
						// æ·»åŠ æ ‡ç­¾
						const label = document.createElement('div');
						label.className = 'detection-label';
						label.textContent = `${detection.package_type} (${(detection.confidence * 100).toFixed(1)}%)`;
						detectionBox.appendChild(label);
						
						selectionOverlay.appendChild(detectionBox);
						drawnBoxes++;
					} else {
						console.warn(`æ£€æµ‹æ¡† ${index} è¶…å‡ºå›¾ç‰‡è¾¹ç•Œï¼Œè·³è¿‡ç»˜åˆ¶:`, {
							calculated: { left, top, width, height },
							imageBounds: { offsetX, offsetY, maxLeft, maxTop }
						});
					}
				}
			});
				
				console.log(`æˆåŠŸç»˜åˆ¶ ${drawnBoxes} ä¸ªæ£€æµ‹æ¡†`);
				
				// ä¿å­˜æ£€æµ‹æ¡†åˆ°imageSelections
				const imageKey = `image_${currentImageIndex}`;
				const selections = [];
				
				// æ”¶é›†æ‰€æœ‰æ£€æµ‹æ¡†çš„ä¿¡æ¯
				const detectionBoxes = selectionOverlay.querySelectorAll('.detection-box');
				detectionBoxes.forEach(box => {
					const label = box.querySelector('.detection-label');
					selections.push({
						type: 'detection',
						left: box.style.left,
						top: box.style.top,
						width: box.style.width,
						height: box.style.height,
						labelText: label ? label.textContent : ''
					});
				});
				
				imageSelections[imageKey] = selections;
				console.log(`ä¿å­˜å›¾ç‰‡ ${currentImageIndex + 1} çš„æ£€æµ‹æ¡†é€‰çŠ¶æ€:`, selections);
				}
				
				// å¦‚æœå›¾åƒå·²ç»åŠ è½½ï¼Œç›´æ¥æ‰§è¡Œ
				if (currentImage.complete && currentImage.naturalWidth > 0) {
					console.log('å›¾åƒå·²åŠ è½½ï¼Œç›´æ¥ç»˜åˆ¶');
					drawBoxes();
				} else {
					console.log('ç­‰å¾…å›¾åƒåŠ è½½å®Œæˆ');
					// ç­‰å¾…å›¾åƒåŠ è½½å®Œæˆ
					currentImage.onload = drawBoxes;
				}
			}

			/**
			 * æå–ä¿¡æ¯
			 */
			async function extractInfo() {
				if (!selectionBox || selectionBox.style.display === 'none') {
					eda.sys_ToastMessage.showMessage('è¯·å…ˆæ¡†é€‰è¦æå–çš„åŒºåŸŸ', 2);
					return;
				}
				
				// æ£€æŸ¥è®¾ç½®æ˜¯å¦å®Œæ•´
				if (!(selectedProvider === 'custom' && apiUrl === 'https://chat.eda.cn/ai-chat-api/complete') && (!apiKey || apiKey.trim() === '')) {
					eda.sys_ToastMessage.showMessage('è¯·åœ¨è®¾ç½®ä¸­é…ç½®APIå¯†é’¥', 0);
					return;
				}
				
				if (selectedProvider === 'custom' && (!apiUrl || apiUrl.trim() === '')) {
					eda.sys_ToastMessage.showMessage('è¯·åœ¨è®¾ç½®ä¸­é…ç½®è‡ªå®šä¹‰APIåœ°å€', 0);
					return;
				}
				
				if (selectedProvider === 'custom' && (!customModel || customModel.trim() === '')) {
					eda.sys_ToastMessage.showMessage('è¯·åœ¨è®¾ç½®ä¸­é…ç½®è‡ªå®šä¹‰æ¨¡å‹åç§°', 0);
					return;
				}
				
				try {
				const currentImage = currentImages[currentImageIndex];
			
			// å°†å›¾ç‰‡è½¬æ¢ä¸ºbase64æ ¼å¼
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');
			const img = new Image();
			
			img.onload = async function() {
				canvas.width = img.width;
				canvas.height = img.height;
				ctx.drawImage(img, 0, 0);
				
				// è‡ªå®šä¹‰APIéœ€è¦JPEGæ ¼å¼ï¼Œå…¶ä»–APIä½¿ç”¨PNGæ ¼å¼
				const imageFormat = isSpecialApiFormat(selectedProvider, apiUrl) ? 'image/jpeg' : 'image/png';
			const mimeType = isSpecialApiFormat(selectedProvider, apiUrl) ? 'jpeg' : 'png';
				const base64Data = canvas.toDataURL(imageFormat).split(',')[1];
				// ä½¿ç”¨å¤šå›¾æ¨¡å¼ï¼Œä¼ å…¥å•å¼ å›¾ç‰‡çš„æ•°ç»„
				const result = await analyzeImage([currentImage.file], [base64Data], [mimeType]);
				
				// è§£æè¿”å›çš„JSONæ•°æ®å¹¶æ·»åŠ åˆ°è¡¨æ ¼
				parseAndAddPins(result.result);
				
				eda.sys_ToastMessage.showMessage('ä¿¡æ¯æå–æˆåŠŸ', 1);
			};
			
			img.onerror = function() {
				eda.sys_ToastMessage.showMessage('å›¾ç‰‡åŠ è½½å¤±è´¥', 0);
			};
			
			img.src = currentImage.src;
			} catch (error) {
				console.error('æå–ä¿¡æ¯å¤±è´¥:', error);
				eda.sys_ToastMessage.showMessage('æå–ä¿¡æ¯å¤±è´¥: ' + error.message, 0);
			}
			}

			/**
			 * æ›´æ–°æŒ‰é’®çŠ¶æ€
			 */
			function updateButtons() {
				// æœç´¢ä½ç½®æŒ‰é’®ï¼šæœ‰å›¾ç‰‡æ—¶å¯ç”¨
				searchPositionButton.disabled = currentImages.length === 0;
				
				// æå–å‚æ•°æŒ‰é’®ï¼šæœ‰æ¡†é€‰ï¼ˆæ‰‹åŠ¨æ¡†é€‰æˆ–æœç´¢ä½ç½®çš„è‡ªåŠ¨æ¡†é€‰ï¼‰æˆ–æœ‰æ£€æµ‹ç»“æœæ—¶å¯ç”¨
				let hasSelections = false;
				for (let i = 0; i < currentImages.length; i++) {
					const imageKey = `image_${i}`;
					const selections = imageSelections[imageKey];
					if (selections && selections.length > 0) {
						hasSelections = true;
						break;
					}
				}
				// å¦‚æœæœ‰æ£€æµ‹ç»“æœï¼Œä¹Ÿå¯ç”¨æå–å‚æ•°æŒ‰é’®
				const hasDetectionResults = detectionResults && detectionResults.pdf_position_list && detectionResults.pdf_position_list.length > 0;
				extractParamsButton.disabled = !hasSelections && !hasDetectionResults;
				
				// æ¸…é™¤æ¡†é€‰æŒ‰é’®ï¼šæœ‰å›¾ç‰‡æ—¶å¯ç”¨
				clearSelectionButton.disabled = currentImages.length === 0;
				
				// æ‰‹åŠ¨æ¡†é€‰æŒ‰é’®ï¼šæœ‰å›¾ç‰‡æ—¶å¯ç”¨
				manualSelectButton.disabled = currentImages.length === 0;
				
				// åˆ›å»ºå°è£…æŒ‰é’®ï¼šæœ‰å‚æ•°æ•°æ®æ—¶å¯ç”¨
				createFootprintButton.disabled = paramData.length === 0;
			}
			
			/**
			 * æ›´æ–°UIçŠ¶æ€
			 */
			function updateUI() {
				updateButtons();
			}

			/**
			 * æ·»åŠ å‚æ•°
			 */
			function addParam() {
				const newParam = {
					name: 'æ–°å‚æ•°',
					key: 'new_param',
					value: '',
					unit: 'mm'
				};
				
				paramData.push(newParam);
				updateParamTable();
				updateUI();
			}

			/**
			 * æ¸…ç©ºè¡¨æ ¼
			 */
			function clearTable() {
				paramData = [];
				packageTypeSelect.value = '';
				updateParamTable();
				updateUI();
			}

			/**
			 * æ›´æ–°å¼•è„šè¡¨æ ¼
			 */
			function updateParamTable() {
				if (paramData.length === 0) {
					pinTableContainer.innerHTML = '<div class="empty-state">æš‚æ— å°è£…å‚æ•°</div>';
					return;
				}
				
				let tableHTML = `
					<table class="pin-table">
						<thead>
							<tr>
								<th>å‚æ•°åç§°</th>
								<th>æ•°å€¼</th>
								<th>å•ä½</th>
								<th>æ“ä½œ</th>
							</tr>
						</thead>
						<tbody>
				`;
				
				paramData.forEach((param, index) => {
					tableHTML += `
						<tr>
							<td>${param.name}</td>
							<td><input type="text" value="${param.value || ''}" onchange="updateParam(${index}, 'value', this.value)"></td>
							<td>${param.unit}</td>
							<td><button onclick="removeParam(${index})">åˆ é™¤</button></td>
						</tr>
					`;
				});
				
				tableHTML += `
						</tbody>
					</table>
				`;
				
				pinTableContainer.innerHTML = tableHTML;
			}

			/**
			 * å°è£…ç±»å‹é€‰æ‹©å˜åŒ–å¤„ç†
			 */
			function onPackageTypeChange() {
				const selectedType = packageTypeSelect.value;
				if (selectedType && packageParams[selectedType]) {
					// æ¸…ç©ºç°æœ‰å‚æ•°æ•°æ®
					paramData = [];
					// æ ¹æ®é€‰æ‹©çš„å°è£…ç±»å‹æ·»åŠ å¯¹åº”å‚æ•°
					packageParams[selectedType].forEach(param => {
						paramData.push({
							name: param.name,
							key: param.key,
							unit: param.unit,
							value: ''
						});
					});
					updateParamTable();
				} else {
					// æ¸…ç©ºå‚æ•°è¡¨æ ¼
					paramData = [];
					updateParamTable();
				}
			}

			/**
			 * æ›´æ–°å‚æ•°æ•°æ®
			 */
			function updateParam(index, field, value) {
				if (paramData[index]) {
					paramData[index][field] = value;
				}
			}



			/**
			 * åˆ é™¤å‚æ•°
			 */
			function removeParam(index) {
				paramData.splice(index, 1);
				updateParamTable();
				updateUI();
			}

			/**
			 * åœæ­¢åˆ†æè¿‡ç¨‹
			 */
			function stopAnalysis() {
				if (!isProcessing) return;
				shouldStopProcessing = true;
				stopButton.disabled = true;
				stopButton.textContent = 'æ­£åœ¨åœæ­¢...';
			}

			/**
			 * å¼€å§‹åˆ†æå›¾ç‰‡
			 */
			async function startAnalysis() {
				// è·å–å½“å‰APIå¯†é’¥å’Œæ¨¡å‹
				eda.sys_ToastMessage.showMessage('å›¾ç‰‡è¯†åˆ«æ­£åœ¨è¿›è¡Œä¸­ï¼Œç­‰å¾…æœŸé—´å¯é€‰æ‹©éšè—çª—å£', 3);
				apiKey = apiKeyInput.value.trim();
				selectedModel = modelSelect.value;
				selectedProvider = providerSelect.value;
				customApiUrl = apiUrlInput.value.trim();

				// ç‰¹æ®ŠAPIä¸éœ€è¦APIå¯†é’¥
				if (!isSpecialApiFormat(selectedProvider, apiUrl) && !apiKey) {
					eda.sys_ToastMessage.showMessage('è¯·è¾“å…¥APIå¯†é’¥', 0);
					return;
				}

				// è‡ªå®šä¹‰æ¨¡å‹éœ€è¦æ£€æŸ¥APIåœ°å€å’Œæ¨¡å‹åç§°
				if (selectedProvider === 'custom') {
					if (!customApiUrl) {
						eda.sys_ToastMessage.showMessage('è¯·è¾“å…¥è‡ªå®šä¹‰APIåœ°å€', 0);
						return;
					}
					if (!selectedModel) {
						eda.sys_ToastMessage.showMessage('è¯·è¾“å…¥è‡ªå®šä¹‰æ¨¡å‹åç§°', 0);
						return;
					}
				}

				eda.sys_Storage.setExtensionUserConfig('api_key', apiKey);
				eda.sys_Storage.setExtensionUserConfig('selected_model', selectedModel);
				if (uploadedFiles.length === 0 || isProcessing) {
					return;
				}

				isProcessing = true;
				updateUI();
				progressContainer.style.display = 'block';
				progressBar.style.width = '0%';
				progressText.textContent = `å¤„ç†ä¸­: 0/${uploadedFiles.length}`;
				resultsList.innerHTML = '';
				analysisResults = [];
				totalInputTokens = 0;
				totalOutputTokens = 0;
				costContainer.style.display = 'none';
				startTime = Date.now();

				setInterval(() => {
					const elapsedTime = Date.now() - startTime;
					const minutes = Math.floor(elapsedTime / 60000);
					const seconds = Math.floor((elapsedTime % 60000) / 1000);
					timerElement.textContent = `å·²ç”¨æ—¶: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
				}, 1000);

				try {
				if (shouldStopProcessing) {
					progressText.textContent = `å·²åœæ­¢: 0/${uploadedFiles.length}`;
					return;
				}

				// å‡†å¤‡æ‰€æœ‰æ–‡ä»¶çš„base64æ•°æ®
				progressText.textContent = 'æ­£åœ¨å‡†å¤‡å›¾ç‰‡æ•°æ®...';
				const base64Images = [];
				const mimeTypes = [];
				
				for (let i = 0; i < uploadedFiles.length; i++) {
					const file = uploadedFiles[i];
					const base64Data = await readFileAsBase64(file);
					base64Images.push(base64Data);
					mimeTypes.push(file.type.split('/')[1] || 'png');
					
					const progress = Math.round(((i + 1) / uploadedFiles.length) * 50); // å‰50%ç”¨äºå‡†å¤‡æ•°æ®
					progressBar.style.width = `${progress}%`;
					progressText.textContent = `å‡†å¤‡å›¾ç‰‡æ•°æ®: ${i + 1}/${uploadedFiles.length}`;
				}

				if (shouldStopProcessing) return;

				// ä¸€æ¬¡æ€§è°ƒç”¨APIå¤„ç†æ‰€æœ‰å›¾ç‰‡
				progressBar.style.width = '75%';
				progressText.textContent = 'æ­£åœ¨è°ƒç”¨AIåˆ†æ...';
				
				const resultData = await analyzeImage(uploadedFiles, base64Images, mimeTypes);
				
				// å¤„ç†ç»“æœ
				for (let i = 0; i < uploadedFiles.length; i++) {
					const file = uploadedFiles[i];
					analysisResults.push({
						filename: file.name,
						result: resultData.result,
						inputTokens: resultData.inputTokens,
						outputTokens: resultData.outputTokens,
						base64: base64Images[i],
						file: file,
						index: i,
						isError: false,
					});
					displayResult(file, base64Images[i], resultData.result);
				}
				
				calculateAndUpdateCost(selectedModel, resultData.inputTokens, resultData.outputTokens);
				
			} catch (error) {
				console.error('æ‰¹é‡å¤„ç†æ–‡ä»¶æ—¶å‡ºé”™:', error);
				if (shouldStopProcessing) return;
				
				// å¦‚æœæ‰¹é‡å¤„ç†å¤±è´¥ï¼Œè®°å½•é”™è¯¯
				for (let i = 0; i < uploadedFiles.length; i++) {
					const file = uploadedFiles[i];
					analysisResults.push({
						filename: file.name,
						errorMessage: error.message,
						inputTokens: 0,
						outputTokens: 0,
						file: file,
						index: i,
						isError: true,
					});
					displayError(file, error.message);
				}
			}

				const processedCount = shouldStopProcessing ? analysisResults.length : uploadedFiles.length;
				progressBar.style.width = '100%';
				progressText.textContent = `å¤„ç†å®Œæˆ: ${processedCount}/${uploadedFiles.length}`;
				setTimeout(() => {
					progressContainer.style.display = 'none';
					progressBar.style.width = '0%';
				}, 2000);

				if (analysisResults.length > 0) {
					downloadAllContainer.style.display = 'block';
				}

				setTimeout(() => {
					isProcessing = false;
					shouldStopProcessing = false;
					updateUI();
				}, 1000);
			}

			/**
			 * è¯»å–æ–‡ä»¶å¹¶è½¬æ¢ä¸ºBase64
			 */
			function readFileAsBase64(file) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = function (e) {
						const base64 = e.target.result.split(',')[1];
						resolve(base64);
					};
					reader.onerror = function (e) {
						reject(new Error('è¯»å–æ–‡ä»¶å¤±è´¥'));
					};
					reader.readAsDataURL(file);
				});
			}

			/**
			 * é€šç”¨APIè°ƒç”¨å‡½æ•°
			 */
			async function callAPI(data) {
				const config = providerConfigs[selectedProvider];
				const url = selectedProvider === 'custom' ? apiUrl : config.apiUrl;
				
				if (isSpecialApiFormat(selectedProvider, apiUrl)) {
				// ç‰¹æ®ŠAPIæ ¼å¼
					const requestData = {
						type: "chat.user.generic_chat",
						context: {
							chat: {
								input_text: data.messages[data.messages.length - 1].content.find(c => c.type === 'text')?.text || '',
								base64_images: data.messages[data.messages.length - 1].content
					.filter(c => c.type === 'image_url')
					.map(c => c.image_url.url)
							},
							history: [],
							messages: []
						}
					};
					
					const headers = {
						'Content-Type': 'application/json',
						'Accept': 'application/json'
					};
					
					return await eda.sys_ClientUrl.request(
						url,
						'POST',
						JSON.stringify(requestData),
						headers
					);
				} else if (selectedProvider === 'zhipu') {
					// æ™ºè°±AIä½¿ç”¨OpenAIå…¼å®¹æ ¼å¼
					if (!apiKey || apiKey.trim() === '') {
						throw new Error('æ™ºè°±AIéœ€è¦APIå¯†é’¥ï¼Œè¯·åœ¨æ¨¡å‹è®¾ç½®ä¸­è¾“å…¥æ‚¨çš„API Key');
					}
					
					const headers = {
						'Content-Type': 'application/json',
						'Authorization': `Bearer ${apiKey.trim()}`
					};
					
					// è½¬æ¢ä¸ºæ™ºè°±AIæ ¼å¼
					const zhipuData = {
						model: data.model,
						messages: data.messages.map(msg => ({
							role: msg.role,
							content: msg.content
						}))
					};
					
					console.log('æ™ºè°±AI APIè°ƒç”¨å‚æ•°:', {
						url: url,
						headers: headers,
						data: zhipuData
					});
					
					return await eda.sys_ClientUrl.request(
						url,
						'POST',
						JSON.stringify(zhipuData),
						{ headers: headers }
					);
				} else if (selectedProvider === 'qwen') {
					// é€šä¹‰åƒé—®ä½¿ç”¨å…¼å®¹æ¨¡å¼æ ¼å¼
					if (!apiKey || apiKey.trim() === '') {
						throw new Error('é€šä¹‰åƒé—®éœ€è¦APIå¯†é’¥ï¼Œè¯·åœ¨æ¨¡å‹è®¾ç½®ä¸­è¾“å…¥æ‚¨çš„API Key');
					}
					
					const headers = {
						'Content-Type': 'application/json',
						'Authorization': `Bearer ${apiKey.trim()}`
					};
					
					// è½¬æ¢ä¸ºå…¼å®¹æ¨¡å¼æ ¼å¼
					const qwenData = {
						model: data.model,
						messages: data.messages.map(msg => ({
							role: msg.role,
							content: msg.content
						}))
					};
					
					return await eda.sys_ClientUrl.request(
						url,
						'POST',
						JSON.stringify(qwenData),
						{ headers: headers }
					);
				} else {
					// è‡ªå®šä¹‰APIæ ¼å¼
					const headers = {
						'Content-Type': 'application/json'
					};
					
					if (config.requiresApiKey && apiKey) {
						headers['Authorization'] = `Bearer ${apiKey}`;
					}
					
					return await eda.sys_ClientUrl.request(
				url,
				'POST',
				JSON.stringify(data),
				{ headers: headers }
			);
				}
			}

			/**
			 * è°ƒç”¨APIåˆ†æå›¾ç‰‡ï¼ˆæ”¯æŒå¤šå›¾æ‰¹é‡å¤„ç†ï¼‰
			 */
			async function analyzeImage(files, base64Images, mimeTypes) {
				if (shouldStopProcessing) {
				throw new Error('ç”¨æˆ·å·²åœæ­¢å¤„ç†');
			}

			// æ„å»ºå¤šå›¾å†…å®¹æ•°ç»„
			const imageContents = [];
			for (let i = 0; i < base64Images.length; i++) {
				// è‡ªå®šä¹‰APIéœ€è¦JPEGæ ¼å¼ï¼Œå…¶ä»–APIä½¿ç”¨åŸå§‹æ ¼å¼
				const imageFormat = isSpecialApiFormat(selectedProvider, apiUrl) ? 'jpeg' : mimeTypes[i];
				imageContents.push({
					type: 'image_url',
					image_url: {
						url: `data:image/${imageFormat};base64,${base64Images[i]}`,
					},
				});
			}
			
			// æ·»åŠ æ–‡æœ¬æç¤º
			imageContents.push({
				type: 'text',
				text: "ä»èŠ¯ç‰‡å°è£…æ‰‹å†Œçš„ç¬¦å·å›¾ä¸­æå–ä»¥ä¸‹ä¿¡æ¯:{['type'],['pinNumber','pinName',]}ï¼Œå›¾åƒ type åŒ…æ‹¬:SOPã€QFNã€BGAã€‚ä¸¥æ ¼è¾“å‡ºJSON",
			});
			
			const data = {
				model: selectedModel,
				vl_high_resolution_images: true,
				messages: [
					{
						role: 'system',
						content: [{ type: 'text', text: 'You are a helpful assistant.' }],
					},
					{
						role: 'user',
						content: imageContents,
					},
				],
			};

			try {
				const response = await callAPI(data);

				if (!response.ok) {
					throw new Error('APIè¯·æ±‚å¤±è´¥');
				}

				const result = await response.json();
				
				if (isSpecialApiFormat(selectedProvider, apiUrl)) {
				// ç‰¹æ®ŠAPIå“åº”æ ¼å¼å¤„ç†
				return {
					result: result.data?.content || result.content || 'è§£æå¤±è´¥',
					inputTokens: 0, // ç‰¹æ®ŠAPIå¯èƒ½ä¸è¿”å›tokenä¿¡æ¯
					outputTokens: 0,
				};
				} else if (selectedProvider === 'zhipu') {
					// æ™ºè°±AIå“åº”æ ¼å¼
					return {
						result: result.choices[0].message.content,
						inputTokens: result.usage?.prompt_tokens || 0,
						outputTokens: result.usage?.completion_tokens || 0,
					};
				} else if (selectedProvider === 'qwen') {
					// é€šä¹‰åƒé—®å…¼å®¹æ¨¡å¼å“åº”æ ¼å¼
					return {
						result: result.choices[0].message.content,
						inputTokens: result.usage?.prompt_tokens || 0,
						outputTokens: result.usage?.completion_tokens || 0,
					};
				} else {
					// è‡ªå®šä¹‰APIå“åº”æ ¼å¼
					return {
						result: result.choices[0].message.content,
						inputTokens: result.usage?.prompt_tokens || 0,
						outputTokens: result.usage?.completion_tokens || 0,
					};
				}
			} catch (error) {
				console.error('APIè°ƒç”¨é”™è¯¯:', error);
				throw new Error(`APIè°ƒç”¨å¤±è´¥: ${error.message}`);
			}
			}

			/**
			 * æ˜¾ç¤ºåˆ†æç»“æœ
			 */
			function displayResult(file, base64, result) {
				const resultCard = document.createElement('div');
				resultCard.className = 'result-card';

				const header = document.createElement('div');
				header.className = 'result-card-header';
				const title = document.createElement('div');
				title.className = 'result-card-title';
				title.textContent = file.name;
				const toggleBtn = document.createElement('button');
				toggleBtn.textContent = 'å±•å¼€';
				toggleBtn.addEventListener('click', () => {
					const content = resultCard.querySelector('.result-card-content');
					if (content.style.display === 'none' || content.style.display === '') {
						content.style.display = 'block';
						toggleBtn.textContent = 'æ”¶èµ·';
					} else {
						content.style.display = 'none';
						toggleBtn.textContent = 'å±•å¼€';
					}
				});
				header.appendChild(title);
				header.appendChild(toggleBtn);

				const content = document.createElement('div');
				content.className = 'result-card-content';
				content.textContent = result;

				const footer = document.createElement('div');
				footer.className = 'result-card-footer';
				const copyBtn = document.createElement('button');
				copyBtn.textContent = 'å¤åˆ¶ç»“æœ';
				copyBtn.addEventListener('click', () => {
					navigator.clipboard
						.writeText(result)
						.then(() => {
							copyBtn.textContent = 'å·²å¤åˆ¶';
							setTimeout(() => {
								copyBtn.textContent = 'å¤åˆ¶ç»“æœ';
							}, 2000);
						})
						.catch((err) => {
							console.error('å¤åˆ¶å¤±è´¥:', err);
							eda.sys_ToastMessage.showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 0);
						});
				});
				const createSymbolBtn = document.createElement('button');
				createSymbolBtn.className = 'create-symbol-btn';
				createSymbolBtn.textContent = 'åˆ›å»ºç¬¦å·';
				createSymbolBtn.addEventListener('click', () => {
					createSymbol(result);
				});
				footer.appendChild(copyBtn);
				footer.appendChild(createSymbolBtn);

				resultCard.appendChild(header);
				resultCard.appendChild(content);
				resultCard.appendChild(footer);

				resultsList.appendChild(resultCard);
			}

			/**
			 * æ˜¾ç¤ºé”™è¯¯ç»“æœ
			 */
			function displayError(file, errorMessage) {
				const resultCard = document.createElement('div');
				resultCard.className = 'result-card error';

				const header = document.createElement('div');
				header.className = 'result-card-header';
				const title = document.createElement('div');
				title.className = 'result-card-title';
				title.textContent = file.name;
				const toggleBtn = document.createElement('button');
				toggleBtn.textContent = 'å±•å¼€';
				toggleBtn.addEventListener('click', () => {
					const content = resultCard.querySelector('.result-card-content');
					if (content.style.display === 'none' || content.style.display === '') {
						content.style.display = 'block';
						toggleBtn.textContent = 'æ”¶èµ·';
					} else {
						content.style.display = 'none';
						toggleBtn.textContent = 'å±•å¼€';
					}
				});
				header.appendChild(title);
				header.appendChild(toggleBtn);

				const content = document.createElement('div');
				content.className = 'result-card-content';
				content.textContent = `å¤„ç†å¤±è´¥: ${errorMessage}`;

				resultCard.appendChild(header);
				resultCard.appendChild(content);

				resultsList.appendChild(resultCard);
			}



			/**
			 * ä¸‹è½½æ‰€æœ‰ç»“æœ
			 */
			function downloadAllResults() {
				if (analysisResults.length === 0) {
					eda.sys_ToastMessage.showMessage('æ²¡æœ‰å¯ä¸‹è½½çš„ç»“æœ', 2);
					return;
				}

				const zip = new JSZip();
				analysisResults.forEach((result) => {
					const filename = `${result.filename.split('.')[0]}.txt`;
					zip.file(filename, result.result);
				});

				zip.generateAsync({ type: 'blob' })
					.then((blob) => {
						const link = document.createElement('a');
						link.href = URL.createObjectURL(blob);
						const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
						link.download = `å›¾ç‰‡åˆ†æç»“æœ_${timestamp}.zip`;
						document.body.appendChild(link);
						link.click();
						document.body.removeChild(link);
						setTimeout(() => URL.revokeObjectURL(link.href), 100);
					})
					.catch((err) => {
						console.error('åˆ›å»ºZIPæ–‡ä»¶å¤±è´¥:', err);
						eda.sys_ToastMessage.showMessage('åˆ›å»ºZIPæ–‡ä»¶å¤±è´¥ï¼Œå°†é€ä¸ªä¸‹è½½ç»“æœ', 2);
						analysisResults.forEach((result) => {
							downloadResult(result.filename, result.result);
						});
					});
			}

			/**
			 * ä¸‹è½½å•ä¸ªç»“æœ
			 */
			function downloadResult(filename, content) {
				const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
				const link = document.createElement('a');
				link.href = URL.createObjectURL(blob);
				link.download = `${filename.split('.')[0]}.txt`;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				setTimeout(() => URL.revokeObjectURL(link.href), 100);
			}

			/**
			 * è®¡ç®—è´¹ç”¨å¹¶æ›´æ–°UI
			 */
			function calculateAndUpdateCost(model, inputTokens, outputTokens) {
				totalInputTokens += inputTokens;
				totalOutputTokens += outputTokens;
				const rates = modelRates[model] || modelRates['qwen-vl-max-latest'];
				const inputCost = (totalInputTokens / 1000) * rates.input;
				const outputCost = (totalOutputTokens / 1000) * rates.output;
				const totalCost = inputCost + outputCost;
				inputTokensElement.textContent = totalInputTokens;
				outputTokensElement.textContent = totalOutputTokens;
				inputCostElement.textContent = `Â¥${inputCost.toFixed(4)}`;
				outputCostElement.textContent = `Â¥${outputCost.toFixed(4)}`;
				totalCostElement.textContent = `Â¥${totalCost.toFixed(4)}`;
				costContainer.style.display = 'block';
			}

			/**
			 * æ™ºèƒ½åŒ¹é…å‚æ•°å®šä¹‰
			 */
			function findMatchingParam(apiParam, paramDataArray) {
				// å®šä¹‰å‚æ•°åˆ«åæ˜ å°„
				const paramAliases = {
					'body_length': ['BL', 'æœ¬ä½“é•¿åº¦', 'body_length', 'å°è£…é•¿åº¦'],
					'body_width': ['BW', 'æœ¬ä½“å®½åº¦', 'body_width', 'å°è£…å®½åº¦'],
					'body_height': ['BH', 'æœ¬ä½“é«˜åº¦', 'body_height', 'å°è£…é«˜åº¦', 'åšåº¦'],
					'pin_count': ['å¼•è„šæ•°é‡', 'pin_count', 'pins', 'pin_number'],
					'lead_span': ['LS', 'å¼•è„šè·¨è·', 'lead_span', 'è·¨è·'],
					'pin_length': ['PL', 'å¼•è„šé•¿åº¦', 'pin_length'],
					'pin_width': ['PW', 'å¼•è„šå®½åº¦', 'pin_width'],
					'pin_pitch': ['PP', 'å¼•è„šé—´è·', 'pin_pitch', 'é—´è·'],
					'pin_spacing': ['PS', 'å¼•è„šé—´è·', 'pin_spacing'],
					'pin_width1': ['PW1', 'å¼•è„šå®½åº¦1', 'pin_width1']
				};
				
				// è·å–APIå‚æ•°çš„åç§°å’Œkey
				const apiName = apiParam.name || '';
				const apiKey = apiParam.key || '';
				
				// é¦–å…ˆå°è¯•ç²¾ç¡®åŒ¹é…
				let existingParam = paramDataArray.find(p => 
					p.key === apiKey || p.name === apiName ||
					p.key === apiName || p.name === apiKey
				);
				
				if (existingParam) {
					return existingParam;
				}
				
				// å¦‚æœç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå°è¯•åˆ«ååŒ¹é…
				for (const [standardKey, aliases] of Object.entries(paramAliases)) {
					// æ£€æŸ¥APIå‚æ•°æ˜¯å¦åŒ¹é…ä»»ä½•åˆ«å
					if (aliases.some(alias => 
						alias === apiName || alias === apiKey ||
						apiName.includes(alias) || apiKey.includes(alias)
					)) {
						// æŸ¥æ‰¾å¯¹åº”çš„æ ‡å‡†å‚æ•°
						existingParam = paramDataArray.find(p => 
							p.key === standardKey ||
							aliases.some(alias => p.name.includes(alias) || p.key.includes(alias))
						);
						
						if (existingParam) {
							return existingParam;
						}
					}
				}
				
				return null;
			}
			
			/**
			 * è§£æå¹¶æ·»åŠ å¼•è„šæ•°æ®
			 */
			function parseAndAddParams(resultText) {
				try {
					console.log('å¼€å§‹è§£æå°è£…å‚æ•°æ•°æ®ï¼ŒåŸå§‹å†…å®¹:', resultText);
					
					// æ™ºè°±AIç‰¹æ®Šæ ‡è®°å¤„ç†
					if (selectedProvider === 'zhipu') {
						// æå–<|begin_of_box|>å’Œ<|end_of_box|>ä¹‹é—´çš„å†…å®¹
						const boxMatch = resultText.match(/<\|begin_of_box\|>([\s\S]*?)<\|end_of_box\|>/);
						if (boxMatch) {
							resultText = boxMatch[1].trim();
							console.log('æ™ºè°±AIæå–çš„JSONå†…å®¹:', resultText);
						}
					}
					
					// æ–¹æ³•1: å°è¯•è§£ææ ‡å‡†çš„```jsonä»£ç å—æˆ–```ä»£ç å—
					const codeBlockRegex = /```(?:json)?\s*([\s\S]*?)\s*```/g;
					let match;
					const jsonContents = [];
					
					while ((match = codeBlockRegex.exec(resultText)) !== null) {
						jsonContents.push(match[1].trim());
					}
					
					if (jsonContents.length > 0) {
						console.log('æ‰¾åˆ°JSONä»£ç å—ï¼Œæ•°é‡:', jsonContents.length);
						
						// éå†æ‰€æœ‰JSONå†…å®¹ï¼Œå¯»æ‰¾åŒ…å«parametersæ•°ç»„çš„
						for (const jsonContent of jsonContents) {
							try {
								console.log('å°è¯•è§£æJSONå†…å®¹:', jsonContent);
								const jsonData = JSON.parse(jsonContent);
								
								if (jsonData.parameters && Array.isArray(jsonData.parameters)) {
									console.log('æ‰¾åˆ°æœ‰æ•ˆçš„parametersæ•°ç»„ï¼Œé•¿åº¦:', jsonData.parameters.length);
									
									// å¦‚æœæ£€æµ‹åˆ°å°è£…ç±»å‹ï¼Œè‡ªåŠ¨è®¾ç½®
							if (jsonData.package_type) {
								let packageType = jsonData.package_type;
								// åŒ…å«BGAçš„å°è£…ç±»å‹è‡ªåŠ¨å½’ç±»åˆ°BGA
										if (packageType && packageType.includes('BGA')) {
											packageType = 'BGA';
										}
										// åŒ…å«DIPçš„å°è£…ç±»å‹è‡ªåŠ¨å½’ç±»åˆ°DIP
										if (packageType && packageType.includes('DIP')) {
											packageType = 'DIP';
										}
							// åŒ…å«DIPçš„å°è£…ç±»å‹è‡ªåŠ¨å½’ç±»åˆ°DIP
							if (packageType && packageType.includes('DIP')) {
								packageType = 'DIP';
							}
								packageTypeSelect.value = packageType;
								onPackageTypeChange();
							}
									
									jsonData.parameters.forEach(param => {
												// æ™ºèƒ½åŒ¹é…å‚æ•°å®šä¹‰
												const existingParam = findMatchingParam(param, paramData);
												if (existingParam) {
													existingParam.value = param.value || '';
												} else {
													// å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”å‚æ•°ï¼Œæ·»åŠ æ–°å‚æ•°
													paramData.push({
														name: param.name || param.key || '',
														key: param.key || param.name || '',
														value: param.value || '',
														unit: param.unit || 'mm'
													});
												}
											});
									updateParamTable();
									updateUI();
									eda.sys_ToastMessage.showMessage(`æˆåŠŸè§£æ ${jsonData.parameters.length} ä¸ªå°è£…å‚æ•°`, 1);
									return;
								}
							} catch (parseError) {
								console.warn('è§£æJSONä»£ç å—å¤±è´¥:', parseError);
								continue;
							}
						}
					}
					
					// æ–¹æ³•2: å°è¯•ç›´æ¥è§£ææ•´ä¸ªå“åº”ä½œä¸ºJSONï¼ˆä¸åœ¨ä»£ç å—ä¸­ï¼‰
					try {
						console.log('å°è¯•ç›´æ¥è§£ææ•´ä¸ªå“åº”ä½œä¸ºJSON');
						const directJsonData = JSON.parse(resultText.trim());
						if (directJsonData.parameters && Array.isArray(directJsonData.parameters)) {
							console.log('ç›´æ¥è§£ææˆåŠŸï¼Œæ‰¾åˆ°æœ‰æ•ˆçš„parametersæ•°ç»„ï¼Œé•¿åº¦:', directJsonData.parameters.length);
							
							// å¦‚æœæ£€æµ‹åˆ°å°è£…ç±»å‹ï¼Œè‡ªåŠ¨è®¾ç½®
				if (directJsonData.package_type) {
					let packageType = directJsonData.package_type;
					// åŒ…å«BGAçš„å°è£…ç±»å‹è‡ªåŠ¨å½’ç±»åˆ°BGA
					if (packageType && packageType.includes('BGA')) {
						packageType = 'BGA';
					}
					// åŒ…å«DIPçš„å°è£…ç±»å‹è‡ªåŠ¨å½’ç±»åˆ°DIP
					if (packageType && packageType.includes('DIP')) {
						packageType = 'DIP';
					}
					packageTypeSelect.value = packageType;
					onPackageTypeChange();
				}
							
							directJsonData.parameters.forEach(param => {
								// æ™ºèƒ½åŒ¹é…å‚æ•°å®šä¹‰
								const existingParam = findMatchingParam(param, paramData);
								if (existingParam) {
									existingParam.value = param.value || '';
								} else {
									// å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”å‚æ•°ï¼Œæ·»åŠ æ–°å‚æ•°
									paramData.push({
										name: param.name || param.key || '',
										key: param.key || param.name || '',
										value: param.value || '',
										unit: param.unit || 'mm'
									});
								}
							});
							updateParamTable();
							updateUI();
							eda.sys_ToastMessage.showMessage(`æˆåŠŸè§£æ ${directJsonData.parameters.length} ä¸ªå°è£…å‚æ•°`, 1);
							return;
						}
					} catch (directParseError) {
						console.log('ç›´æ¥è§£æJSONå¤±è´¥:', directParseError);
					}
					
					// æ–¹æ³•3: å°è¯•æŸ¥æ‰¾JSONå¯¹è±¡ï¼ˆä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼‰
					const directJsonMatch = resultText.match(/\{[\s\S]*?"parameters"[\s\S]*?\}/g);
					if (directJsonMatch && directJsonMatch.length > 0) {
						console.log('æ‰¾åˆ°ç›´æ¥JSONå¯¹è±¡ï¼Œæ•°é‡:', directJsonMatch.length);
						
						for (const jsonStr of directJsonMatch) {
							try {
								const jsonData = JSON.parse(jsonStr);
								if (jsonData.parameters && Array.isArray(jsonData.parameters)) {
									console.log('æ‰¾åˆ°æœ‰æ•ˆçš„parametersæ•°ç»„ï¼Œé•¿åº¦:', jsonData.parameters.length);
									
									// å¦‚æœæ£€æµ‹åˆ°å°è£…ç±»å‹ï¼Œè‡ªåŠ¨è®¾ç½®
											if (jsonData.package_type) {
												let packageType = jsonData.package_type;
												// åŒ…å«BGAçš„å°è£…ç±»å‹è‡ªåŠ¨å½’ç±»åˆ°BGA
												if (packageType && packageType.includes('BGA')) {
													packageType = 'BGA';
												}
												packageTypeSelect.value = packageType;
												onPackageTypeChange();
											}
									
									jsonData.parameters.forEach(param => {
													// æ™ºèƒ½åŒ¹é…å‚æ•°å®šä¹‰
													const existingParam = findMatchingParam(param, paramData);
													if (existingParam) {
														existingParam.value = param.value || '';
													} else {
														// å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”å‚æ•°ï¼Œæ·»åŠ æ–°å‚æ•°
														paramData.push({
															name: param.name || param.key || '',
															key: param.key || param.name || '',
															value: param.value || '',
															unit: param.unit || 'mm'
														});
													}
												});
									updateParamTable();
									updateUI();
									eda.sys_ToastMessage.showMessage(`æˆåŠŸè§£æ ${jsonData.parameters.length} ä¸ªå°è£…å‚æ•°`, 1);
									return;
								}
							} catch (parseError) {
								console.warn('è§£æç›´æ¥JSONå¤±è´¥:', parseError);
								continue;
							}
						}
					}
					
					// å¦‚æœæ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥äº†
					console.error('æ‰€æœ‰è§£ææ–¹æ³•éƒ½å¤±è´¥äº†');
					eda.sys_ToastMessage.showMessage('æ— æ³•è§£æå°è£…å‚æ•°ï¼Œè¯·æ£€æŸ¥APIè¿”å›æ ¼å¼', 0);
					
				} catch (error) {
					console.error('è§£æå°è£…å‚æ•°æ•°æ®å¤±è´¥:', error);
					console.error('åŸå§‹å†…å®¹:', resultText);
					eda.sys_ToastMessage.showMessage('è§£æå°è£…å‚æ•°æ•°æ®å¤±è´¥: ' + error.message, 0);
				}
			}

			/**
			 * åˆ›å»ºå°è£…ï¼ˆä»è¡¨æ ¼æ•°æ®ï¼‰
			 */
			function createFootprintFromTable() {
				const selectedType = packageTypeSelect.value;
				if (!selectedType) {
					eda.sys_ToastMessage.showMessage('è¯·å…ˆé€‰æ‹©å°è£…ç±»å‹', 2);
					return;
				}
				
				if (paramData.length === 0) {
					eda.sys_ToastMessage.showMessage('è¯·å…ˆæ·»åŠ å°è£…å‚æ•°', 2);
					return;
				}
				
				try {
					
					// æ„å»ºå°è£…å‚æ•°å¯¹è±¡
					const footprintParams = {};
					paramData.forEach(param => {
						if (param.value && param.value.trim() !== '') {
							footprintParams[param.key] = parseFloat(param.value) || param.value;
						}
					});
					
					console.log('å°è£…ç±»å‹:', selectedType);
				console.log('å°è£…å‚æ•°:', footprintParams);
				
				// åˆ›å»ºå°è£…
				const success = createFootprint(selectedType, footprintParams);
				
				if (success) {
					eda.sys_IFrame.hideIFrame('footprint');
					eda.sys_ToastMessage.showMessage('å°è£…åˆ›å»ºæˆåŠŸï¼Œæ”¯æŒåœ¨èœå•ä¸­é€šè¿‡ç‚¹å‡»"ç»§ç»­åˆ›å»º"é€‰é¡¹ä»¥é‡æ–°æ‰“å¼€çª—å£', 3);
				}
				} catch (error) {
					console.error('åˆ›å»ºå°è£…å¤±è´¥:', error);
					eda.sys_ToastMessage.showMessage('åˆ›å»ºå°è£…å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ä»¥è·å–è¯¦ç»†ä¿¡æ¯', 0);
				}
			}

			function createSymbol(jsonData) {
				try {
					// å»é™¤ä»£ç å—æ ‡è®°
					jsonData = jsonData.replace(/```json\n/, '').replace(/\n```$/, '');

					// å°è¯•è§£æJSONæ•°æ®
					const data = JSON.parse(jsonData);

					// æ£€æŸ¥JSONæ•°æ®æ˜¯å¦åŒ…å«å¿…è¦çš„å­—æ®µ
					if (!data || typeof data !== 'object' || !data.type || !Array.isArray(data.pins)) {
						throw new Error('JSONæ•°æ®æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘typeæˆ–pinså­—æ®µ');
					}

					const type = data.type;
					const pins = data.pins;

					console.log('è§£æçš„JSONæ•°æ®:', data);

					// åˆ›å»ºç¬¦å·è¾¹æ¡†ï¼Œä¼ é€’å¼•è„šæ€»æ•°
					let bbox = createSymbolBoundingBox(type, pins.length);
					console.log('åˆ›å»ºçš„ç¬¦å·è¾¹æ¡†:', bbox);

					console.log('type0', type);
					// åˆ›å»ºå¼•è„š
					createSymbolPins(pins, bbox, type);
					console.log('å¼•è„šåˆ›å»ºå®Œæˆ');

					eda.sys_IFrame.hideIFrame('footprint');
					eda.sys_ToastMessage.showMessage('ç¬¦å·åˆ›å»ºæˆåŠŸï¼Œæ”¯æŒåœ¨èœå•ä¸­é€šè¿‡ç‚¹å‡»â€œç»§ç»­åˆ›å»ºâ€é€‰é¡¹ä»¥é‡æ–°æ‰“å¼€çª—å£', 3);
				} catch (error) {
					console.error('åˆ›å»ºç¬¦å·å¤±è´¥:', error);
					eda.sys_ToastMessage.showMessage('åˆ›å»ºç¬¦å·å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ä»¥è·å–è¯¦ç»†ä¿¡æ¯', 0);
				}
			}

			/**
			 * æ ¹æ®å¼•è„šæ€»æ•°é‡åŠ¨æ€åˆ›å»ºç¬¦å·è¾¹æ¡†
			 */
			function createSymbolBoundingBox(type, pinCount) {
				if (!pinCount || isNaN(pinCount) || pinCount <= 0) {
					throw new Error('æ— æ•ˆçš„å¼•è„šæ•°é‡: ' + pinCount);
				}

				let aspectRatio = 1.2;

				if (type === 'SOP') {
					aspectRatio = 0.45;
				}

				const pinSpacing = 20; // æ¯ä¸ªå¼•è„šæ‰€éœ€çš„æœ€å°é—´è·

				// æ ¹æ®å¼•è„šæ•°é‡è®¡ç®—å®½åº¦å’Œé«˜åº¦
				const totalPinsPerSide = Math.ceil(pinCount / 4); // æ¯è¾¹çš„å¼•è„šæ•°é‡
				const width = totalPinsPerSide * pinSpacing * aspectRatio; // å®½åº¦ä¸å¼•è„šæ•°é‡æˆæ¯”ä¾‹
				const height = totalPinsPerSide * pinSpacing; // é«˜åº¦ä¸å¼•è„šæ•°é‡æˆæ¯”ä¾‹

				// åˆ›å»ºè¾¹æ¡†çš„ç‚¹åæ ‡
				const bbox = [0, 0, width, 0, width, height, 0, height, 0, 0];

				// ä½¿ç”¨ eda.sch_PrimitivePolygon.create åˆ›å»ºç¬¦å·è¾¹æ¡†
				eda.sch_PrimitivePolygon.create(bbox);

				// éªŒè¯ bbox æ˜¯å¦æœ‰æ•ˆ
				if (bbox.some((value) => isNaN(value))) {
					throw new Error('ç”Ÿæˆçš„è¾¹æ¡†åæ ‡æ— æ•ˆ: ' + bbox);
				}

				return bbox;
			}

			/**
			 * åˆ›å»ºç¬¦å·å¼•è„š
			 */
			function createSymbolPins(pins, bbox, type) {
				if (!Array.isArray(pins) || pins.length === 0) {
					throw new Error('æ— æ•ˆçš„å¼•è„šæ•°æ®: ' + pins);
				}

				if (!Array.isArray(bbox) || bbox.length < 8 || bbox.some((value) => isNaN(value))) {
					throw new Error('æ— æ•ˆçš„è¾¹æ¡†æ•°æ®: ' + bbox);
				}
				console.log('type1', type);
				pins.forEach((pin, pinIndex) => {
					const pinNumber = pin.pinNumber;
					const pinName = pin.pinName;
					console.log('type2', type);
					let x = 0,
						y = 0,
						rotation = 0; // æ—‹è½¬è§’åº¦
					const pinCount = pins.length;

					// æ ¹æ®ç±»å‹å†³å®šæ¯è¾¹çš„å¼•è„šæ•°é‡
					const sidePinCount =
						type === 'SOP'
							? Math.ceil(pinCount / 2) // å¦‚æœæ˜¯ SOP ç±»å‹ï¼Œæ¯è¾¹åˆ†é…ä¸€åŠå¼•è„š
							: Math.ceil((pinCount + 4) / 4) - 1; // å…¶ä»–ç±»å‹ï¼Œæ¯è¾¹åˆ†é…å¼•è„šæ•°é‡ï¼ˆå»æ‰é¡¶ç‚¹ï¼‰

					const side =
						type === 'SOP'
							? pinIndex < sidePinCount
								? 0
								: 2 // å¦‚æœæ˜¯ SOP ç±»å‹ï¼Œåªä½¿ç”¨å·¦è¾¹(0)å’Œå³è¾¹(2)
							: Math.floor(pinIndex / sidePinCount); // å…¶ä»–ç±»å‹ï¼ŒæŒ‰å››è¾¹åˆ†é…

					const index =
						type === 'SOP'
							? pinIndex % sidePinCount // å¦‚æœæ˜¯ SOP ç±»å‹ï¼ŒæŒ‰å·¦å³ä¸¤è¾¹åˆ†é…
							: pinIndex % sidePinCount; // å…¶ä»–ç±»å‹ï¼ŒæŒ‰å››è¾¹åˆ†é…

					const normalizedIndex = sidePinCount > 1 ? (index + 1) / (sidePinCount + 1) : 0;
					console.log('type3', type);
					switch (side) {
						case 0: // left (é€†æ—¶é’ˆç¬¬1è¾¹)
							x = bbox[0] - 20; // å‘å·¦ç§»åŠ¨20
							y = bbox[5] - (bbox[5] - bbox[1]) * normalizedIndex;
							rotation = 180; // æ—‹è½¬è§’åº¦180
							break;
						case 1: // bottom (é€†æ—¶é’ˆç¬¬2è¾¹)
							if (type !== 'SOP') {
								// SOP ç±»å‹ä¸åˆ›å»ºåº•è¾¹å¼•è„š
								x = bbox[0] + (bbox[2] - bbox[0]) * normalizedIndex; // æ²¿ç€åº•è¾¹ä»å·¦åˆ°å³
								y = bbox[1] - 20; // å‘ä¸Šç§»åŠ¨20
								rotation = 270; // æ—‹è½¬è§’åº¦270
							}
							break;
						case 2: // right (é€†æ—¶é’ˆç¬¬3è¾¹)
							x = bbox[2] + 20; // å‘å³ç§»åŠ¨20
							y = bbox[1] + (bbox[5] - bbox[1]) * normalizedIndex;
							rotation = 0; // æ—‹è½¬è§’åº¦0
							break;
						case 3: // top (é€†æ—¶é’ˆç¬¬4è¾¹)
							if (type !== 'SOP') {
								// SOP ç±»å‹ä¸åˆ›å»ºé¡¶è¾¹å¼•è„š
								x = bbox[2] - (bbox[2] - bbox[0]) * normalizedIndex; // æ²¿ç€é¡¶è¾¹ä»å³åˆ°å·¦
								y = bbox[5] + 20; // å‘ä¸‹ç§»åŠ¨20
								rotation = 90; // æ—‹è½¬è§’åº¦90
							}
							break;
					}

					if (isNaN(x) || isNaN(y)) {
						throw new Error(`å¼•è„šåæ ‡æ— æ•ˆ: pinNumber=${pinNumber}, pinName=${pinName}, x=${x}, y=${y}`);
					}

					console.log('åˆ›å»ºå¼•è„š:', pinNumber, pinName, x, y, rotation);
				eda.sch_PrimitivePin.create(x, y, pinNumber, pinName, rotation);
			});
		}

		/**
		 * åˆ›å»ºå°è£…
		 * @returns {boolean} æ˜¯å¦æˆåŠŸåˆ›å»ºå°è£…
		 */
		function createFootprint(packageType, params) {
			console.log('å¼€å§‹åˆ›å»ºå°è£…:', packageType, params);
			
			// æ£€æŸ¥æ˜¯å¦ä¸ºæš‚ä¸æ”¯æŒçš„å°è£…ç±»å‹
			const unsupportedTypes = ['SOD', 'SOT23', 'SOT223'];
			if (unsupportedTypes.includes(packageType)) {
				eda.sys_ToastMessage.showMessage('è¯¥å°è£…ç±»å‹æš‚ä¸æ”¯æŒåˆ›å»º', 2);
				return false;
			}
			
			// è¿™é‡Œåº”è¯¥è°ƒç”¨EDAçš„å°è£…åˆ›å»ºAPI
			// ç”±äºä¸åŒçš„å°è£…ç±»å‹éœ€è¦ä¸åŒçš„åˆ›å»ºé€»è¾‘ï¼Œè¿™é‡Œæä¾›ä¸€ä¸ªåŸºç¡€æ¡†æ¶
			
			switch (packageType) {
				case 'BGA':
				case 'CSP_BGA':
					createBGAFootprint(params);
					break;
				case 'DIP':
					createDIPFootprint(params);
					break;
				case 'QFN':
					createQFNFootprint(params);
					break;
				case 'QFP':
					createQFPFootprint(params);
					break;
				case 'SOP':
					createSOPFootprint(params);
					break;
				default:
					throw new Error('ä¸æ”¯æŒçš„å°è£…ç±»å‹: ' + packageType);
			}
			
			return true;
		}

		/**
		 * åˆ›å»ºBGAå°è£…
		 */
		function createBGAFootprint(params) {
			console.log('åˆ›å»ºBGAå°è£…:', params);
			
			// è·å–å‚æ•°ï¼Œè®¾ç½®é»˜è®¤å€¼
			const pinRows = parseInt(params['å¼•è„šè¡Œæ•°']) || parseInt(params.pin_rows) || 11; // å¼•è„šè¡Œæ•°
			const pinCols = parseInt(params['å¼•è„šåˆ—æ•°']) || parseInt(params.pin_cols) || 11; // å¼•è„šåˆ—æ•°
			const bodyLength = parseFloat(params['æœ¬ä½“é•¿åº¦']) || parseFloat(params['æœ¬ä½“é•¿åº¦(BL)']) || parseFloat(params.body_length) || parseFloat(params.BL) || 6.2; // æœ¬ä½“é•¿åº¦(BL)
			const bodyWidth = parseFloat(params['æœ¬ä½“å®½åº¦']) || parseFloat(params['æœ¬ä½“å®½åº¦(BW)']) || parseFloat(params.body_width) || parseFloat(params.BW) || 6.2; // æœ¬ä½“å®½åº¦(BW)
			const pinDiameter = parseFloat(params['å¼•è„šç›´å¾„']) || parseFloat(params['å¼•è„šç›´å¾„(PD)']) || parseFloat(params.pin_diameter) || parseFloat(params.PD) || 0.3; // å¼•è„šç›´å¾„(PD)
			const pinSpacing = parseFloat(params['å¼•è„šé—´è·']) || parseFloat(params['å¼•è„šé—´è·(PS)']) || parseFloat(params.pin_spacing) || parseFloat(params.PS) || 0.5; // å¼•è„šé—´è·(PS)
			// å¼•è„šçºµå‘é—´è·(PP)ï¼Œå¦‚æœæ²¡æœ‰æä¾›PPå‚æ•°ï¼Œåˆ™ä½¿ç”¨PSçš„å€¼
			const pinPitchVertical = parseFloat(params['å¼•è„šçºµå‘é—´è·']) || parseFloat(params['å¼•è„šçºµå‘é—´è·(PP)']) || parseFloat(params.pin_pitch_vertical) || parseFloat(params.PP) || pinSpacing; // å¼•è„šçºµå‘é—´è·(PP)
			
			console.log('BGAå‚æ•°:', {
				pinRows, pinCols, bodyLength, bodyWidth, 
				pinDiameter, pinSpacing, pinPitchVertical
			});
			
			// è½¬æ¢ä¸ºEDAå•ä½(milï¼Œ1mm = 39.3701mil)
			const mmToMil = 39.3701;
			const bodyLengthMil = bodyLength * mmToMil;
			const bodyWidthMil = bodyWidth * mmToMil;
			const pinDiameterMil = pinDiameter * mmToMil;
			const pinSpacingMil = pinSpacing * mmToMil;
			const pinPitchVerticalMil = pinPitchVertical * mmToMil;
			
			// è®¡ç®—å¼•è„šé˜µåˆ—çš„èµ·å§‹ä½ç½®ï¼ˆå·¦ä¸Šè§’ï¼‰
			const startX = -(pinCols - 1) * pinSpacingMil / 2;
			const startY = (pinRows - 1) * pinPitchVerticalMil / 2;
			
			// ç”ŸæˆBGAå¼•è„šæ ‡å·ï¼ˆA1, A2, ..., B1, B2, ...ï¼‰
			function getBGAPinName(row, col) {
				const rowLetter = String.fromCharCode(65 + row); // A, B, C, ...
				const colNumber = col + 1; // 1, 2, 3, ...
				return rowLetter + colNumber;
			}
			
			// åˆ›å»ºBGAå¼•è„šé˜µåˆ—
			for (let row = 0; row < pinRows; row++) {
				for (let col = 0; col < pinCols; col++) {
					const x = startX + col * pinSpacingMil;
					const y = startY - row * pinPitchVerticalMil;
					const pinName = getBGAPinName(row, col);
					
					// åˆ›å»ºåœ†å½¢ç„Šç›˜ï¼ˆBGAå¼•è„šä¸ºçƒå½¢ç„Šç‚¹ï¼‰
					eda.pcb_PrimitivePad.create(
						EPCB_LayerId.TOP,
						pinName,
						x, y, 0,
						[EPCB_PrimitivePadShapeType.ELLIPSE, pinDiameterMil, pinDiameterMil]
					);
				}
			}
			
			// åˆ›å»ºä¸å°è½®å»“ï¼ˆå°è£…å¤–å½¢ï¼‰- ä½¿ç”¨å›ºå®šå°ºå¯¸
			const outlineX = silkWidth / 2; // ä¸å°æ¡†å®½åº¦çš„ä¸€åŠ
			const outlineY = silkLength / 2; // ä¸å°æ¡†é•¿åº¦çš„ä¸€åŠ
			
			// åˆ›å»ºä¸‰è¾¹çŸ©å½¢å¤–æ¡†ï¼ˆä¸åŒ…å«ä¸Šè¾¹ï¼Œä¸ºåœ†å¼§ç•™å‡ºç©ºé—´ï¼‰
			// å·¦è¾¹
			const leftLine = eda.pcb_MathPolygon.createPolygon([
				-outlineX, outlineY, 'L', -outlineX, -outlineY
			]);
			// ä¸‹è¾¹
			const bottomLine = eda.pcb_MathPolygon.createPolygon([
				-outlineX, -outlineY, 'L', outlineX, -outlineY
			]);
			// å³è¾¹
			const rightLine = eda.pcb_MathPolygon.createPolygon([
				outlineX, -outlineY, 'L', outlineX, outlineY
			]);
			
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, leftLine, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, bottomLine, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, rightLine, 6);
			
			// åœ¨A1è§’è½ï¼ˆå·¦ä¸Šè§’ï¼‰æ·»åŠ æŒ‡ç¤ºæ ‡è®°
			const markSize = 12; // æ ‡è®°å¤§å°(mil)
			const markOffset = 4; // æ ‡è®°åç§»é‡(mil)
			
			// åˆ›å»ºA1è§’è½çš„ä¸‰è§’å½¢æ ‡è®°
			const triangleMark = eda.pcb_MathPolygon.createPolygon([
				-outlineX + markOffset, outlineY - markOffset, 'L',
				-outlineX + markOffset + markSize, outlineY - markOffset, 'L',
				-outlineX + markOffset, outlineY - markOffset - markSize, 'L',
				-outlineX + markOffset, outlineY - markOffset
			]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, triangleMark, 6);
			
			// æ·»åŠ A1æ ‡è¯†åœ†ç‚¹
			const dotX = -outlineX + markOffset + markSize / 2;
			const dotY = outlineY - markOffset - markSize / 2;
			const dotRadius = 2; // å°åœ†ç‚¹åŠå¾„(mil)
			const dotCircle = eda.pcb_MathPolygon.createPolygon([dotX, dotY, 'A', dotX + dotRadius, dotY, dotX, dotY]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, dotCircle, 6);
			
			console.log('BGAå°è£…åˆ›å»ºå®Œæˆï¼Œæ€»å¼•è„šæ•°:', pinRows * pinCols);
		}

		/**
		 * åˆ›å»ºDIPå°è£…
		 */
		function createDIPFootprint(params) {
			console.log('åˆ›å»ºDIPå°è£…:', params);
			
			// è·å–å‚æ•°ï¼Œè®¾ç½®é»˜è®¤å€¼
			const pinCount = parseInt(params.pin_count) || 16; // å¼•è„šæ•°é‡
			const leadSpan = parseFloat(params.LS) || 7.62; // å¼•è„šè·¨è·(LS)
			const bodyLength = parseFloat(params.BL) || 9.27; // æœ¬ä½“é•¿åº¦(BL)
			const bodyWidth = parseFloat(params.BW) || 7.87; // æœ¬ä½“å®½åº¦(BW)
			const pinDiameter = parseFloat(params.PD) || 0.46; // å¼•è„šç›´å¾„(PD)
			const pinPitch = parseFloat(params.PP) || 2.54; // å¼•è„šé—´è·(PP)
			
			console.log('DIPå‚æ•°:', {
				pinCount, leadSpan, bodyLength, bodyWidth, 
				pinDiameter, pinPitch
			});
			
			// è½¬æ¢ä¸ºEDAå•ä½(milï¼Œ1mm = 39.3701mil)
			const mmToMil = 39.3701;
			const leadSpanMil = leadSpan * mmToMil;
			const bodyLengthMil = bodyLength * mmToMil;
			const bodyWidthMil = bodyWidth * mmToMil;
			const pinDiameterMil = pinDiameter * mmToMil;
			const pinPitchMil = pinPitch * mmToMil;
			
			// å›ºå®šç„Šç›˜ç›´å¾„ä¸º65milï¼Œä¸å°æ¡†å°ºå¯¸ä¸º371Ã—230.2mil
			const padDiameter = 65; // ç„Šç›˜ç›´å¾„(mil)
			const silkLength = 371; // ä¸å°æ¡†é•¿åº¦(mil)
			const silkWidth = 230.2; // ä¸å°æ¡†å®½åº¦(mil)
			
			// è®¡ç®—æ¯ä¾§å¼•è„šæ•°é‡
			const pinsPerSide = pinCount / 2;
			
			// åˆ›å»ºå¼•è„š
			let pinNumber = 1;
			
			// å·¦ä¾§å¼•è„š (å¼•è„š1å¼€å§‹ï¼Œä»ä¸Šåˆ°ä¸‹)
			for (let i = 0; i < pinsPerSide; i++) {
				const y = (pinsPerSide - 1) * pinPitchMil / 2 - i * pinPitchMil;
				const x = -leadSpanMil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 0,
					[EPCB_PrimitivePadShapeType.ELLIPSE, padDiameter, padDiameter]
				);
				pinNumber++;
			}
			
			// å³ä¾§å¼•è„š (ä»ä¸‹åˆ°ä¸Š)
			for (let i = 0; i < pinsPerSide; i++) {
				const y = -(pinsPerSide - 1) * pinPitchMil / 2 + i * pinPitchMil;
				const x = leadSpanMil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 0,
					[EPCB_PrimitivePadShapeType.ELLIPSE, padDiameter, padDiameter]
				);
				pinNumber++;
			}
			
			// åˆ›å»ºä¸å°è½®å»“ï¼ˆå°è£…å¤–å½¢ï¼‰
			const outlineX = silkWidth / 2;  // ä½¿ç”¨å›ºå®šçš„ä¸å°å®½åº¦
			const outlineY = silkLength / 2; // ä½¿ç”¨å›ºå®šçš„ä¸å°é•¿åº¦
			
			// åˆ›å»ºå·¦è¾¹çº¿
			const leftLine = eda.pcb_MathPolygon.createPolygon([
				-outlineX, outlineY, 'L', -outlineX, -outlineY
			]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, leftLine, 6);
			
			// åˆ›å»ºå³è¾¹çº¿
			const rightLine = eda.pcb_MathPolygon.createPolygon([
				outlineX, outlineY, 'L', outlineX, -outlineY
			]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, rightLine, 6);
			
			// åˆ›å»ºä¸‹è¾¹çº¿
			const bottomLine = eda.pcb_MathPolygon.createPolygon([
				-outlineX, -outlineY, 'L', outlineX, -outlineY
			]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, bottomLine, 6);
			
			// åœ¨ä¸Šè¾¹åˆ›å»ºä¸¤æ¡çŸ­çº¿å’Œè¿æ¥åœ†å¼§ï¼ˆå‚è€ƒæ–‡æ¡£ç»“æ„ï¼‰
			const arcGap = 86.8; // åœ†å¼§ä¸¤ç«¯çš„é—´éš™é•¿åº¦(mil)ï¼Œæ ¹æ®å‚è€ƒæ–‡æ¡£è®¡ç®—
			
			// åˆ›å»ºå·¦ä¾§çŸ­çº¿
			const leftShortLine = eda.pcb_MathPolygon.createPolygon([
				-outlineX, outlineY, 'L', -arcGap/2, outlineY
			]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, leftShortLine, 6);
			
			// åˆ›å»ºå³ä¾§çŸ­çº¿
			const rightShortLine = eda.pcb_MathPolygon.createPolygon([
				arcGap/2, outlineY, 'L', outlineX, outlineY
			]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, rightShortLine, 6);
			
			// åˆ›å»ºè¿æ¥åœ†å¼§ï¼ˆ180åº¦åœ†å¼§ï¼‰
			const connectingArc = eda.pcb_MathPolygon.createPolygon([
				-arcGap/2, outlineY, 'ARC', 180, arcGap/2, outlineY
			]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, connectingArc, 6);
			
			console.log('DIPå°è£…åˆ›å»ºå®Œæˆï¼Œæ€»å¼•è„šæ•°:', pinCount);
		}

		/**
		 * åˆ›å»ºQFNå°è£…
		 */
		function createQFNFootprint(params) {
			console.log('åˆ›å»ºQFNå°è£…:', params);
			
			// è·å–å‚æ•°ï¼Œè®¾ç½®é»˜è®¤å€¼
			const pinCountLR = parseInt(params.pin_count_lr) || 6; // å·¦å³å¼•è„šæ•°
			const pinCountTB = parseInt(params.pin_count_tb) || 8; // ä¸Šä¸‹å¼•è„šæ•°
			const bodyLength = parseFloat(params.body_length) || 5.0; // æœ¬ä½“é•¿åº¦(BL)
			const bodyWidth = parseFloat(params.body_width) || 4.0; // æœ¬ä½“å®½åº¦(BW)
			const pinLength = parseFloat(params.pin_length) || 0.4; // å¼•è„šé•¿åº¦(PL)
			const pinWidth = parseFloat(params.pin_width) || 0.25; // å¼•è„šå®½åº¦(PW)
			const pinPitch = parseFloat(params.pin_pitch) || 0.5; // å¼•è„šé—´è·(PP)
			
			console.log('QFNå‚æ•°:', {
				pinCountLR, pinCountTB, bodyLength, bodyWidth, 
				pinLength, pinWidth, pinPitch
			});
			
			// è½¬æ¢ä¸ºEDAå•ä½(milï¼Œ1mm = 39.3701mil)
			const mmToMil = 39.3701;
			const bodyLengthMil = bodyLength * mmToMil;
			const bodyWidthMil = bodyWidth * mmToMil;
			const pinLengthMil = pinLength * mmToMil;
			const pinWidthMil = pinWidth * mmToMil;
			const pinPitchMil = pinPitch * mmToMil;
			
			// è®¡ç®—å¼•è„šä½ç½®
			let pinNumber = 1;
			
			// å·¦ä¾§å¼•è„š (å¼•è„š1å¼€å§‹ï¼Œä»ä¸Šåˆ°ä¸‹)
			for (let i = 0; i < pinCountLR; i++) {
				const y = (pinCountLR - 1) * pinPitchMil / 2 - i * pinPitchMil;
				const x = -bodyWidthMil / 2 - pinLengthMil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 0,
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// åº•éƒ¨å¼•è„š (ä»å·¦åˆ°å³)
			for (let i = 0; i < pinCountTB; i++) {
				const x = -(pinCountTB - 1) * pinPitchMil / 2 + i * pinPitchMil;
				const y = -bodyLengthMil / 2 - pinLengthMil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 1.57, // 90åº¦æ—‹è½¬
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// å³ä¾§å¼•è„š (ä»ä¸‹åˆ°ä¸Š)
			for (let i = 0; i < pinCountLR; i++) {
				const y = -(pinCountLR - 1) * pinPitchMil / 2 + i * pinPitchMil;
				const x = bodyWidthMil / 2 + pinLengthMil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 0,
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// é¡¶éƒ¨å¼•è„š (ä»å³åˆ°å·¦)
			for (let i = 0; i < pinCountTB; i++) {
				const x = (pinCountTB - 1) * pinPitchMil / 2 - i * pinPitchMil;
				const y = bodyLengthMil / 2 + pinLengthMil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 1.57, // 90åº¦æ—‹è½¬
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// åˆ›å»ºä¸å°è½®å»“
			const silkOffset = 6; // ä¸å°åç§»é‡(mil)
			const silkLength = 18; // ä¸å°çº¿æ®µé•¿åº¦(mil)
			const outlineX = bodyWidthMil / 2 + silkOffset;
			const outlineY = bodyLengthMil / 2 + silkOffset;
			
			// åˆ›å»ºå››ä¸ªè§’çš„ä¸å°çº¿æ®µ
			// å·¦ä¸Šè§’
			const line1 = eda.pcb_MathPolygon.createPolygon([-outlineX, outlineY, 'L', -outlineX + silkLength, outlineY]);
			const line2 = eda.pcb_MathPolygon.createPolygon([-outlineX, outlineY, 'L', -outlineX, outlineY - silkLength]);
			
			// å·¦ä¸‹è§’
			const line3 = eda.pcb_MathPolygon.createPolygon([-outlineX, -outlineY, 'L', -outlineX, -outlineY + silkLength]);
			const line4 = eda.pcb_MathPolygon.createPolygon([-outlineX, -outlineY, 'L', -outlineX + silkLength, -outlineY]);
			
			// å³ä¸‹è§’
			const line5 = eda.pcb_MathPolygon.createPolygon([outlineX, -outlineY, 'L', outlineX - silkLength, -outlineY]);
			const line6 = eda.pcb_MathPolygon.createPolygon([outlineX, -outlineY, 'L', outlineX, -outlineY + silkLength]);
			
			// å³ä¸Šè§’
			const line7 = eda.pcb_MathPolygon.createPolygon([outlineX, outlineY, 'L', outlineX - silkLength, outlineY]);
			const line8 = eda.pcb_MathPolygon.createPolygon([outlineX, outlineY, 'L', outlineX, outlineY - silkLength]);
			
			// åˆ›å»ºä¸å°
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line1, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line2, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line3, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line4, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line5, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line6, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line7, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line8, 6);
			
			console.log('QFNå°è£…åˆ›å»ºå®Œæˆï¼Œæ€»å¼•è„šæ•°:', pinNumber - 1);
		}

		/**
		 * åˆ›å»ºQFPå°è£… (Quad Flat Package - å››æ–¹æ‰å¹³å°è£…)
		 */
		function createQFPFootprint(params) {
			console.log('åˆ›å»ºQFPå°è£…:', params);
			
			// è·å–å‚æ•°ï¼Œè®¾ç½®é»˜è®¤å€¼
			const pinCountLR = parseInt(params.pin_count_lr) || parseInt(params['å¼•è„šæ•°(å·¦å³)']) || 14; // å·¦å³å¼•è„šæ•°
			const pinCountTB = parseInt(params.pin_count_tb) || parseInt(params['å¼•è„šæ•°(ä¸Šä¸‹)']) || 14; // ä¸Šä¸‹å¼•è„šæ•°
			const leadSpan1 = parseFloat(params.lead_span1) || parseFloat(params.LS1) || parseFloat(params['å¼•è„šè·¨è·(LS1)']) || 9.0; // å¼•è„šè·¨è·(LS1)
			const leadSpan2 = parseFloat(params.lead_span2) || parseFloat(params.LS2) || parseFloat(params['å¼•è„šçºµå‘è·¨è·(LS2)']) || 9.0; // å¼•è„šçºµå‘è·¨è·(LS2)
			const bodyLength = parseFloat(params.body_length) || parseFloat(params.BL) || parseFloat(params['æœ¬ä½“é•¿åº¦(BL)']) || 7.0; // æœ¬ä½“é•¿åº¦(BL)
			const bodyWidth = parseFloat(params.body_width) || parseFloat(params.BW) || parseFloat(params['æœ¬ä½“å®½åº¦(BW)']) || 7.0; // æœ¬ä½“å®½åº¦(BW)
			const pinLength = parseFloat(params.pin_length) || parseFloat(params.PL) || parseFloat(params['å¼•è„šé•¿åº¦(PL)']) || 0.6; // å¼•è„šé•¿åº¦(PL)
			const pinWidth = parseFloat(params.pin_width) || parseFloat(params.PW) || parseFloat(params['å¼•è„šå®½åº¦(PW)']) || 0.3; // å¼•è„šå®½åº¦(PW)
			const pinPitch = parseFloat(params.pin_pitch) || parseFloat(params.PP) || parseFloat(params['å¼•è„šé—´è·(PP)']) || 0.5; // å¼•è„šé—´è·(PP)
			
			console.log('QFPå‚æ•°:', {
				pinCountLR, pinCountTB, leadSpan1, leadSpan2,
				bodyLength, bodyWidth, pinLength, pinWidth, pinPitch
			});
			
			// è½¬æ¢ä¸ºEDAå•ä½(milï¼Œ1mm = 39.3701mil)
			const mmToMil = 39.3701;
			const leadSpan1Mil = leadSpan1 * mmToMil;
			const leadSpan2Mil = leadSpan2 * mmToMil;
			const bodyLengthMil = bodyLength * mmToMil;
			const bodyWidthMil = bodyWidth * mmToMil;
			const pinLengthMil = pinLength * mmToMil;
			const pinWidthMil = pinWidth * mmToMil;
			const pinPitchMil = pinPitch * mmToMil;
			
			// è®¡ç®—å¼•è„šä½ç½®
			let pinNumber = 1;
			
			// å·¦ä¾§å¼•è„š (å¼•è„š1å¼€å§‹ï¼Œä»ä¸Šåˆ°ä¸‹)
			for (let i = 0; i < pinCountLR; i++) {
				const y = (pinCountLR - 1) * pinPitchMil / 2 - i * pinPitchMil;
				const x = -leadSpan1Mil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 0,
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// åº•éƒ¨å¼•è„š (ä»å·¦åˆ°å³)
			for (let i = 0; i < pinCountTB; i++) {
				const x = -(pinCountTB - 1) * pinPitchMil / 2 + i * pinPitchMil;
				const y = -leadSpan2Mil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 1.57, // 90åº¦æ—‹è½¬
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// å³ä¾§å¼•è„š (ä»ä¸‹åˆ°ä¸Š)
			for (let i = 0; i < pinCountLR; i++) {
				const y = -(pinCountLR - 1) * pinPitchMil / 2 + i * pinPitchMil;
				const x = leadSpan1Mil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 0,
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// é¡¶éƒ¨å¼•è„š (ä»å³åˆ°å·¦)
			for (let i = 0; i < pinCountTB; i++) {
				const x = (pinCountTB - 1) * pinPitchMil / 2 - i * pinPitchMil;
				const y = leadSpan2Mil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP,
					pinNumber.toString(),
					x, y, 1.57, // 90åº¦æ—‹è½¬
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// åˆ›å»ºä¸å°è½®å»“ï¼ˆå››ä¸ªè§’çš„Lå½¢æ ‡è®°ï¼‰
			const silkOffset = 8; // ä¸å°åç§»é‡(mil)
			const silkLength = 20; // ä¸å°çº¿æ®µé•¿åº¦(mil)
			const outlineX = bodyWidthMil / 2 + silkOffset;
			const outlineY = bodyLengthMil / 2 + silkOffset;
			
			// åˆ›å»ºå››ä¸ªè§’çš„ä¸å°çº¿æ®µ
			// å·¦ä¸Šè§’ - å¸¦æœ‰ç¬¬ä¸€å¼•è„šæ ‡è®°
			const line1 = eda.pcb_MathPolygon.createPolygon([-outlineX, outlineY, 'L', -outlineX + silkLength, outlineY]);
			const line2 = eda.pcb_MathPolygon.createPolygon([-outlineX, outlineY, 'L', -outlineX, outlineY - silkLength]);
			
			// å·¦ä¸‹è§’
			const line3 = eda.pcb_MathPolygon.createPolygon([-outlineX, -outlineY, 'L', -outlineX, -outlineY + silkLength]);
			const line4 = eda.pcb_MathPolygon.createPolygon([-outlineX, -outlineY, 'L', -outlineX + silkLength, -outlineY]);
			
			// å³ä¸‹è§’
			const line5 = eda.pcb_MathPolygon.createPolygon([outlineX, -outlineY, 'L', outlineX - silkLength, -outlineY]);
			const line6 = eda.pcb_MathPolygon.createPolygon([outlineX, -outlineY, 'L', outlineX, -outlineY + silkLength]);
			
			// å³ä¸Šè§’
			const line7 = eda.pcb_MathPolygon.createPolygon([outlineX, outlineY, 'L', outlineX - silkLength, outlineY]);
			const line8 = eda.pcb_MathPolygon.createPolygon([outlineX, outlineY, 'L', outlineX, outlineY - silkLength]);
			
			// åˆ›å»ºä¸å°
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line1, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line2, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line3, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line4, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line5, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line6, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line7, 6);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, line8, 6);
			
			// åœ¨å·¦ä¸Šè§’æ·»åŠ ç¬¬ä¸€å¼•è„šæ ‡è®°ï¼ˆå°åœ†ç‚¹ï¼‰
			const dotX = -outlineX + silkLength / 2;
			const dotY = outlineY - silkLength / 2;
			const dotRadius = 3; // å°åœ†ç‚¹åŠå¾„(mil)
			const dotCircle = eda.pcb_MathPolygon.createPolygon([dotX, dotY, 'A', dotX + dotRadius, dotY, dotX, dotY]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, dotCircle, 6);
			
			console.log('QFPå°è£…åˆ›å»ºå®Œæˆï¼Œæ€»å¼•è„šæ•°:', pinNumber - 1);
		}

		/**
		 * åˆ›å»ºSOPå°è£… (Small Outline Package - å°å¤–å½¢å°è£…)
		 */
		function createSOPFootprint(params) {
			console.log('åˆ›å»ºSOPå°è£…:', params);
			
			// è·å–å‚æ•°ï¼Œè®¾ç½®é»˜è®¤å€¼
			const pinCount = parseInt(params.pin_count) || parseInt(params['å¼•è„šæ•°é‡']) || 8;
			const leadSpan = parseFloat(params.lead_span) || parseFloat(params.LS) || parseFloat(params['å¼•è„šè·¨è·(LS)']) || 5.8;
			const bodyLength = parseFloat(params.body_length) || parseFloat(params.BL) || parseFloat(params['æœ¬ä½“é•¿åº¦(BL)']) || 4.9;
			const bodyWidth = parseFloat(params.body_width) || parseFloat(params.BW) || parseFloat(params['æœ¬ä½“å®½åº¦(BW)']) || 3.9;
			const pinLength = parseFloat(params.pin_length) || parseFloat(params.PL) || parseFloat(params['å¼•è„šé•¿åº¦(PL)']) || 0.6;
			const pinWidth = parseFloat(params.pin_width) || parseFloat(params.PW) || parseFloat(params['å¼•è„šå®½åº¦(PW)']) || 0.4;
			const pinPitch = parseFloat(params.pin_pitch) || parseFloat(params.PP) || parseFloat(params['å¼•è„šé—´è·(PP)']) || 1.27;
			
			console.log('SOPå‚æ•°:', { pinCount, leadSpan, bodyLength, bodyWidth, pinLength, pinWidth, pinPitch });
			
			// è½¬æ¢ä¸ºEDAå•ä½(milï¼Œ1mm = 39.3701mil)
			const mmToMil = 39.3701;
			const leadSpanMil = leadSpan * mmToMil;
			const bodyLengthMil = bodyLength * mmToMil;
			const bodyWidthMil = bodyWidth * mmToMil;
			const pinLengthMil = pinLength * mmToMil;
			const pinWidthMil = pinWidth * mmToMil;
			const pinPitchMil = pinPitch * mmToMil;
			
			const pinsPerSide = pinCount / 2;
			let pinNumber = 1;
			
			// å·¦ä¾§å¼•è„š
			for (let i = 0; i < pinsPerSide; i++) {
				const y = (pinsPerSide - 1) * pinPitchMil / 2 - i * pinPitchMil;
				const x = -leadSpanMil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP, pinNumber.toString(), x, y, 0,
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// å³ä¾§å¼•è„š
			for (let i = 0; i < pinsPerSide; i++) {
				const y = -(pinsPerSide - 1) * pinPitchMil / 2 + i * pinPitchMil;
				const x = leadSpanMil / 2;
				eda.pcb_PrimitivePad.create(
					EPCB_LayerId.TOP, pinNumber.toString(), x, y, 0,
					[EPCB_PrimitivePadShapeType.RECTANGLE, pinLengthMil, pinWidthMil, 0]
				);
				pinNumber++;
			}
			
			// åˆ›å»ºä¸å°è½®å»“
			const silkOffset = 6;
			const outlineX = bodyWidthMil / 2 + silkOffset;
			const outlineY = bodyLengthMil / 2 + silkOffset;
			
			const leftLine = eda.pcb_MathPolygon.createPolygon([-outlineX, outlineY, 'L', -outlineX, -outlineY]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, leftLine, 6);
			
			const rightLine = eda.pcb_MathPolygon.createPolygon([outlineX, outlineY, 'L', outlineX, -outlineY]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, rightLine, 6);
			
			const bottomLine = eda.pcb_MathPolygon.createPolygon([-outlineX, -outlineY, 'L', outlineX, -outlineY]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, bottomLine, 6);
			
			const arcGap = 40;
			const leftShortLine = eda.pcb_MathPolygon.createPolygon([-outlineX, outlineY, 'L', -arcGap/2, outlineY]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, leftShortLine, 6);
			
			const rightShortLine = eda.pcb_MathPolygon.createPolygon([arcGap/2, outlineY, 'L', outlineX, outlineY]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, rightShortLine, 6);
			
			const connectingArc = eda.pcb_MathPolygon.createPolygon([-arcGap/2, outlineY, 'ARC', 180, arcGap/2, outlineY]);
			eda.pcb_PrimitivePolyline.create('line', EPCB_LayerId.TOP_SILKSCREEN, connectingArc, 6);
			
			console.log('SOPå°è£…åˆ›å»ºå®Œæˆï¼Œæ€»å¼•è„šæ•°:', pinCount);
		}

		/**
		 * åˆ›å»ºSODå°è£…
		 */
		function createSODFootprint(params) {
			console.log('åˆ›å»ºSODå°è£…:', params);
			// å®é™…çš„SODå°è£…åˆ›å»ºé€»è¾‘
		}

		/**
		 * åˆ›å»ºSOT23å°è£…
		 */
		function createSOT23Footprint(params) {
			console.log('åˆ›å»ºSOT23å°è£…:', params);
			// å®é™…çš„SOT23å°è£…åˆ›å»ºé€»è¾‘
		}

		/**
		 * åˆ›å»ºSOT223å°è£…
		 */
		function createSOT223Footprint(params) {
			console.log('åˆ›å»ºSOT223å°è£…:', params);
			// å®é™…çš„SOT223å°è£…åˆ›å»ºé€»è¾‘
		}
		
		/**
		 * åˆå§‹åŒ–å›¾ç‰‡é¢„è§ˆåŠŸèƒ½
		 */
		function initImagePreview() {
			const imagePreviewModal = document.getElementById('image-preview-modal');
			const previewImage = document.getElementById('preview-image');
			const closePreviewBtn = document.getElementById('close-preview');
			const previewInfo = document.getElementById('preview-info');
			
			// å…³é—­é¢„è§ˆ
			function closePreview() {
				imagePreviewModal.style.display = 'none';
				previewImage.src = '';
			}
			
			// å…³é—­æŒ‰é’®ç‚¹å‡»äº‹ä»¶
			closePreviewBtn.addEventListener('click', (e) => {
				e.stopPropagation();
				closePreview();
			});
			
			// ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
			imagePreviewModal.addEventListener('click', (e) => {
				if (e.target === imagePreviewModal) {
					closePreview();
				}
			});
			
			// ESCé”®å…³é—­
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape' && imagePreviewModal.style.display === 'flex') {
					closePreview();
				}
			});
			
			// ä¸ºå›¾ç‰‡æ·»åŠ ç‚¹å‡»é¢„è§ˆåŠŸèƒ½
			function addImageClickPreview() {
				const currentImage = document.getElementById('current-image');
				if (currentImage && currentImages.length > 0) {
					// ç§»é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
					const newImage = currentImage.cloneNode(true);
					currentImage.parentNode.replaceChild(newImage, currentImage);
					
					// é‡æ–°è·å–æ–°çš„å›¾ç‰‡å…ƒç´ 
					const freshImage = document.getElementById('current-image');
					freshImage.style.cursor = 'pointer';
					freshImage.style.pointerEvents = 'auto';
					
					freshImage.addEventListener('click', (e) => {
						// é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘æ¡†é€‰åŠŸèƒ½
						e.stopPropagation();
						
						// å¦‚æœæ­£åœ¨æ‰‹åŠ¨é€‰æ‹©æ¨¡å¼ï¼Œä¸è§¦å‘é¢„è§ˆ
						if (manualSelectionMode) {
							return;
						}
						
						// æ˜¾ç¤ºé¢„è§ˆ
						const currentImageData = currentImages[currentImageIndex];
						previewImage.src = currentImageData.src;
						previewInfo.textContent = currentImageData.name || `é¡µé¢ ${currentImageIndex + 1}`;
						imagePreviewModal.style.display = 'flex';
					});
				}
			}
			
			// ç›‘å¬å›¾ç‰‡æ˜¾ç¤ºæ›´æ–°ï¼Œä¸ºæ–°å›¾ç‰‡æ·»åŠ é¢„è§ˆåŠŸèƒ½
			const originalDisplayCurrentImage = displayCurrentImage;
			displayCurrentImage = function() {
				originalDisplayCurrentImage.apply(this, arguments);
				// å»¶è¿Ÿæ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œç¡®ä¿å›¾ç‰‡å·²ç»åŠ è½½
				setTimeout(addImageClickPreview, 100);
			};
		}
		
		// åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–å›¾ç‰‡é¢„è§ˆåŠŸèƒ½
		document.addEventListener('DOMContentLoaded', function() {
			initImagePreview();
		});
	</script>
</body>
</html>
